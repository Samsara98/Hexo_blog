<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SamsarA</title>
  
  
  <link href="https://wk1044481101.github.io/atom.xml" rel="self"/>
  
  <link href="https://wk1044481101.github.io/"/>
  <updated>2021-06-15T11:04:20.280Z</updated>
  <id>https://wk1044481101.github.io/</id>
  
  <author>
    <name>SamsarA</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Concurrency and Parallelism</title>
    <link href="https://wk1044481101.github.io/2021/05/31/Concurrency%20and%20Parallelism/"/>
    <id>https://wk1044481101.github.io/2021/05/31/Concurrency%20and%20Parallelism/</id>
    <published>2021-05-31T08:46:37.000Z</published>
    <updated>2021-06-15T11:04:20.280Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://samsara98.gitee.io/samsara/">SamsarA’s Blog</a>! If you get any problems when reading my blog, you can<br>ask me on <a href="https://gitee.com/samsara98/samsara">Gitee</a>.</p><h1 id="Concurrency-and-Parallelism"><a href="#Concurrency-and-Parallelism" class="headerlink" title="Concurrency and Parallelism"></a>Concurrency and Parallelism</h1><pre><code>#Thread #Lock </code></pre><p>&nbsp; You can get source code on my <a href="https://gitee.com/samsara98/">Gitee</a>.</p><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><h3 id="互斥锁与自旋锁"><a href="#互斥锁与自旋锁" class="headerlink" title="互斥锁与自旋锁"></a>互斥锁与自旋锁</h3><p>最底层的两种就是会「互斥锁和自旋锁」，有很多高级的锁都是基于它们实现的，你可以认为它们是各种锁的地基</p><p>加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。</p><p>当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：</p><ul><li><p>互斥锁加锁失败后，线程会释放 CPU ，给其他线程</p></li><li><p>自旋锁加锁失败后，线程会忙等待，直到它拿到锁</p></li></ul><p>自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对。</p><p>如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。</p><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，</p><p>只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞。</p><p>对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的。当加锁失败时，</p><p>内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。</p><p><img src="https://oscimg.oschina.net/oscnet/e15a17cd-ded1-463c-877b-5c248c85912f.png" alt="1.png"></p><p>互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。</p><p>那这个开销成本是什么呢？会有两次线程上下文切换的成本：</p><ul><li><p>当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；</p></li><li><p>接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。</p></li></ul><p>线程的上下文切换的是什么？当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</p><p>上下切换的耗时有大佬统计过，大概在几十纳秒到几微秒之间，如果你锁住的代码执行时间比较短，那可能上下文切换的时间都比你锁住的代码执行时间还要长。</p><hr><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>自旋锁是通过 CPU 提供的 CAS 函数（Compare And Swap），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。</p><p>一般加锁的过程，包含两个步骤：</p><ol><li><p>查看锁的状态，如果锁是空闲的，则执行第二步</p></li><li><p>第二步，将锁设置为当前线程持有</p></li></ol><p>自旋锁是最比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。</p><p>需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。</p><p>否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。</p><p>旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步、协程等在用户态切换请求的编程方式，</p><p>但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系</p><hr><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁从字面意思我们也可以知道，它由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。</p><p>所以，读写锁适用于能明确区分读操作和写操作的场景。</p><ul><li>只允许一个线程写入（其他线程既不能写入也不能读取）；</li><li>没有写入时，多个线程允许同时读（提高性能）。</li><li>适合读多写少的场景。</li></ul><p>工作原理</p><ul><li><p>当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。</p></li><li><p>但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。</p></li></ul><hr><h4 id="ReadWriteLock-and-StampedLock"><a href="#ReadWriteLock-and-StampedLock" class="headerlink" title="ReadWriteLock and StampedLock"></a>ReadWriteLock and StampedLock</h4><p>ReadWriteLock可以解决多线程同时读，但只有一个线程能写的问题。</p><p>如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。</p><p>要进一步提升并发执行效率，Java 8引入了新的读写锁：StampedLock。</p><p>StampedLock和ReadWriteLock相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。</p><p>乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</p><p>和ReadWriteLock相比，写入的加锁是完全一样的，不同的是读取。首先获取一个乐观读锁，并返回版本号。接着进行读取，读取完成后去验证版本号，</p><p>如果在读取过程中没有写入，版本号不变，验证成功，我们就可以放心地继续后续操作。</p><p>如果在读取过程中有写入，版本号会发生变化，验证将失败。在失败的时候，我们再通过获取悲观读锁再次读取。由于写入的概率不高，程序在绝大部分情况下可以通过乐观读锁获取数据，极少数情况下使用悲观读锁获取数据。</p><p>可见，StampedLock把读锁细分为乐观读和悲观读，能进一步提升并发效率。但这也是有代价的：一是代码更加复杂，二是StampedLock是不可重入锁，不能在一个线程中反复获取同一个锁。</p><p>StampedLock还提供了更复杂的将悲观读锁升级为写锁的功能，它主要使用在if-then-update的场景：即先读，如果读的数据满足条件，就返回，如果读的数据不满足条件，再尝试写。</p><ul><li><p>StampedLock提供了乐观读锁，可取代ReadWriteLock以进一步提升并发性能；</p></li><li><p>StampedLock是不可重入锁。</p></li></ul><hr><h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><ul><li><p>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</p></li><li><p>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升</p></li></ul><hr><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>互斥锁、自旋锁、读写锁，都是属于悲观锁。</p><p>认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。</p><hr><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>假定冲突的概率很低，它的工作方式是：先修改完共享资源，再验证这段时间内有没有发生冲突，</p><p>如果没有其他线程在修改资源，那么操作完成，</p><p>如果发现有其他线程已经修改过这个资源，就放弃本次操作。</p><p>乐观锁全程并没有加锁，所以它也叫无锁编程。</p><hr><h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。</p><p>在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。 java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p><p>CAS算法涉及到三个操作数：</p><ul><li>需要读写的内存值 V。</li><li>进行比较的值 A。</li><li>要写入的新值 B。</li></ul><p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p><p>CAS虽然很高效，但是它也存在三大问题：</p><ol><li>ABA问题。</li></ol><p>CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。</p><p>但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</p><p>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。<br>2. 循环时间长开销大。</p><p>CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。<br>3. 只能保证一个共享变量的原子操作。</p><p>对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</p><p>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</p><hr><h5 id="乐观锁应用"><a href="#乐观锁应用" class="headerlink" title="乐观锁应用"></a>乐观锁应用</h5><ul><li>在线文档</li></ul><p>我们都知道在线文档可以同时多人编辑的，如果使用了悲观锁，那么只要有一个用户正在编辑文档，此时其他用户就无法打开相同的文档了，这用户体验当然不好了。</p><p>那实现多人同时编辑，实际上是用了乐观锁，它允许多个用户打开同一个文档进行编辑，编辑完提交之后才验证修改的内容是否有冲突。</p><p>怎么样才算发生冲突？这里举个例子，比如用户 A 先在浏览器编辑文档，之后用户 B 在浏览器也打开了相同的文档进行编辑，</p><p>当 A 提交修改完的内容时，那么 A 和 B 之间并行修改的地方就会发生冲突。</p><p>服务端要怎么验证是否冲突了呢？通常方案如下：</p><ul><li><p>由于发生冲突的概率比较低，所以先让用户编辑文档，但是浏览器在下载文档时会记录下服务端返回的文档版本号；</p></li><li><p>当用户提交修改时，发给服务端的请求会带上原始文档版本号，服务器收到后将它与当前版本号进行比较，如果版本号一致则修改成功，否则提交失败。</p></li></ul><p>实际上，我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。</p><p>乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。</p><hr><h3 id="可重入锁和不可重入锁"><a href="#可重入锁和不可重入锁" class="headerlink" title="可重入锁和不可重入锁"></a>可重入锁和不可重入锁</h3><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。</p><p>Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p><p>当线程请求一个未被持有的锁时,JVM将记下锁的持有者,并且将获取计数值置为1,如果同一个线程再次获取这个锁,计数值将递增,退出一次同步代码块,计算值递减,当计数值为0时,这个锁就被释放。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://samsara98.gitee.io/samsara/&quot;&gt;SamsarA’s Blog&lt;/a&gt;! If you get any problems when reading my blog, you can&lt;br&gt;ask</summary>
      
    
    
    
    <category term="Study" scheme="https://wk1044481101.github.io/categories/Study/"/>
    
    
    <category term="-Java" scheme="https://wk1044481101.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CORS and Transaction</title>
    <link href="https://wk1044481101.github.io/2021/05/26/CORS%20and%20Transaction/"/>
    <id>https://wk1044481101.github.io/2021/05/26/CORS%20and%20Transaction/</id>
    <published>2021-05-26T07:16:37.000Z</published>
    <updated>2021-07-01T09:50:20.500Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://samsara98.gitee.io/samsara/">SamsarA’s Blog</a>! If you get any problems when reading my blog, you can<br>ask me on <a href="https://gitee.com/samsara98/samsara">Gitee</a>.</p><h1 id="CORS-and-Transaction"><a href="#CORS-and-Transaction" class="headerlink" title="CORS and Transaction"></a>CORS and Transaction</h1><pre><code>#SpringBoot #Redis #Mybatics</code></pre><p>&nbsp; You can get source code on my <a href="https://gitee.com/samsara98/adamall">Gitee</a>.</p><h2 id="前端安全"><a href="#前端安全" class="headerlink" title="前端安全"></a>前端安全</h2><hr><h3 id="浏览器同源政策"><a href="#浏览器同源政策" class="headerlink" title="浏览器同源政策"></a>浏览器同源政策</h3><p>同源政策是浏览器的一个安全政策</p><ul><li>目的：是为了防止将用户信息恶意的盗取传输</li><li>同源含义：域名（IP），协议头， 端口三者相同</li><li>MDN同源政策的内容：<ul><li>通常允许跨域写操作 ：重定向以及表单提交。</li><li>通常允许跨域资源嵌入：script\link\img\video\iframe</li><li>不允许跨域读操作: ajax</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">URL                                         结果 原因<br>http:&#x2F;&#x2F;store.company.com&#x2F;dir2&#x2F;other.html        同源 只有路径不同<br>http:&#x2F;&#x2F;store.company.com&#x2F;dir&#x2F;inner&#x2F;another.html 同源 只有路径不同<br>https:&#x2F;&#x2F;store.company.com&#x2F;secure.html         失败 协议不同<br>http:&#x2F;&#x2F;store.company.com:81&#x2F;dir&#x2F;etc.html        失败 端口不同 (http:&#x2F;&#x2F;默认端口是80)<br>http:&#x2F;&#x2F;news.company.com&#x2F;dir&#x2F;other.html         失败 主机不同<br></code></pre></td></tr></table></figure><p>不允许跨域读操作， 那么就代表了有三种操作会受到同源政策的限制。</p><p>即不同源网站间的AJAX的请求，网站间的DOM操作，以及两者间的cookie和indexDB之间的访问。</p><p>即同源政策通过限制你获取当前用户记录在其他源下的cookie等</p><p>记录在浏览器端的用户数据，以及限制了使用AJAX发送数据到其他的源的方式，以此来保障安全。</p><p>&nbsp;</p><hr><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><ul><li>CORS - Cross Origin Resourse-Sharing - 跨站资源共享</li></ul><p>由于浏览器的安全策略——同源政策，进行web开发经常会遇到跨域问题.</p><p>于是在XMLHttpRequest v2标准下，提出了CORS(Cross Origin Resourse-Sharing)的模型，试图提供安全方便的跨域读写资源。目前主流浏览器均支持CORS。</p><p>CORS定义了两种跨域请求，简单跨域请求和非简单跨域请求。</p><p>&nbsp;</p><h4 id="CORS-请求类型"><a href="#CORS-请求类型" class="headerlink" title="CORS 请求类型"></a>CORS 请求类型</h4><ul><li>简单跨域请求：</li></ul><p>请求方法为HEAD，GET，POST;请求头只有4个字段，Accept，Accept-Language，Content-Language，Last-Event-ID;<br>如果设置了Content-Type，则其值只能是application/x-www-form-urlencoded,multipart/form-data,text/plain。</p><ul><li>非简单请求:不满足简单跨域请求的请求;</li></ul><h4 id="CORS流程"><a href="#CORS流程" class="headerlink" title="CORS流程"></a>CORS流程</h4><p>浏览器对简单请求和非简单请求的处理机制不一样。</p><p>当我们需要发送一个跨域请求的时候，浏览器会首先检查这个请求，如果它符合上面所述的简单跨域请求，浏览器就会立刻发送这个请求。</p><p>如果浏览器检查之后发现这是一个非简单请求，比如请求头含有X-Forwarded-For字段。这时候浏览器不会马上发送这个请求，</p><p>而是有一个preflight，跟服务器验证的过程。如果预检通过，则发送这个请求，否则就不拒绝发送这个跨域请求。</p><ul><li><p>浏览器和服务器的合作判定步骤如下：</p><ol><li><p>浏览器先根据同源策略对前端页面和后台交互地址做匹配，若同源，则直接发送数据请求；若不同源，则发送跨域请求。</p></li><li><p>服务器解析程序收到浏览器跨域请求后，根据自身配置返回对应文件头。若未配置过任何允许跨域，则文件头里不包含Access-Control-Allow-origin字段，<br>若配置过域名，则返回Access-Control-Allow-origin+ 对应配置规则里的域名的方式。</p></li><li><p>浏览器根据接受到的http文件头里的Access-Control-Allow-origin字段做匹配，若无该字段，说明不允许跨域；若有该字段，则对字段内容和当前域名做比对，<br>如果同源，则说明可以跨域，浏览器发送该请求；若不同源，则说明该域名不可跨域，不发送请求</p></li></ol></li></ul><hr><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><ul><li>CSRF - Cross-Site Request Forgery - 跨站请求伪造</li></ul><p>同源政策通过限制你获取当前用户记录在其他源下的cookie等记录在浏览器端的用户数据，以及限制了使用AJAX发送数据到其他的源的方式，以此来保障安全。</p><p>csrf利用的是同源政策允许跨域表单提交，以及允许跨域请求资源完成的攻击。</p><p>&nbsp;</p><h4 id="CSRF攻击分类"><a href="#CSRF攻击分类" class="headerlink" title="CSRF攻击分类"></a>CSRF攻击分类</h4><p>CSRF漏洞一般分为站外和站内两种类型:</p><ol><li>CSRF站外类型</li></ol><p>本质上就是传统意义上的外部提交数据问题。</p><p>通常程序员会考虑给一些留言或者评论的表单加上水印以防止SPAM问题（这里，SPAM可以简单的理解为垃圾留言、垃圾评论，或者是带有站外链接的恶意回复），</p><p>但是有时为了提高用户的体验性，可能没有对一些操作做任何限制，所以攻击者可以事先预测并设置请求的参数，</p><p>在站外的Web页面里编写脚本伪造文件请求，或者和自动提交的表单一起使用来实现GET、POST请求，</p><p>当用户在会话状态下点击链接访问站外Web页面，客户端就被强迫发起请求。</p><ol start="2"><li>CSRF站内类型的漏洞</li></ol><p>在一定程度上是由于程序员滥用REQUEST类变量造成的。</p><p>在一些敏感的操作中（如修改密码、添加用户等），本来要求用户从表单提交发起POST请求传递参数给程序，但是由于使用了</p><p>_REQUEST等变量，程序除支持接收POST请求传递的参数外也支持接收GET请求传递的参数，这样就会为攻击者使用CSRF攻击创造条件。</p><p>一般攻击者只要把预测的请求参数放在站内一个贴子或者留言的图片链接里，受害者浏览了这样的页面就会被强迫发起这些请求。</p><h4 id="CSRF原理"><a href="#CSRF原理" class="headerlink" title="CSRF原理"></a>CSRF原理</h4><p>http传输是无状态的，即两个请求之前是完全无联系的，那么网站就会面临如何去识别一个用户的登录态的问题。</p><p>维持登录态一般的方式就是利用http头部的cookie存储一些信息，然后利用浏览器，访问一个域名下其他页面请求，浏览器会携带当前域下的cookie这一特性，在服务端进行识别。</p><ul><li><p>cookie存储的用于识别的信息一般也会有两种： 一种是类似于JWT的，在用户登录后将用户的信息加密编码将得到的token塞到cookie里，然后验证就是通过解密检查是否存在某个字段，</p><p>另一种则是使用session，将sessionId塞到cookie里面。</p></li></ul><p>用户的身份识别就是利用cookie，那么冒充用户身份的方式即利用访问一个域名下其他页面请求，浏览器会携带当前域下的cookie这一特性。</p><h4 id="CSRF实现"><a href="#CSRF实现" class="headerlink" title="CSRF实现"></a>CSRF实现</h4><p>常见的攻击类型：</p><ul><li>GET类型的CSRF</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">![](https<br>:<span class="hljs-comment">//awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/ff0cdbee.example/withdraw?amount=10000&amp;for=hacker)</span><br></code></pre></td></tr></table></figure><p>GET类型的CSRF利用非常简单，只需要一个HTTP请求，在受害者访问特定的页面后，浏览器会自动向受害者已经登录并记录cookie的网站发出一次HTTP请求。<br>在用户不知情的情况下，目标网站就会收到一次跨域请求，因为浏览器自动携带cookie，因此得以伪装身份。</p><p>&nbsp;</p><ul><li>POST类型的CSRF</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"> &lt;form action=<span class="hljs-string">&quot;http://bank.example/withdraw&quot;</span> method=POST&gt;<br>    &lt;input type=<span class="hljs-string">&quot;hidden&quot;</span> name=<span class="hljs-string">&quot;account&quot;</span> value=<span class="hljs-string">&quot;xiaoming&quot;</span>/&gt;<br>    &lt;input type=<span class="hljs-string">&quot;hidden&quot;</span> name=<span class="hljs-string">&quot;amount&quot;</span> value=<span class="hljs-string">&quot;10000&quot;</span>/&gt;<br>    &lt;input type=<span class="hljs-string">&quot;hidden&quot;</span> name=<span class="hljs-string">&quot;for&quot;</span> value=<span class="hljs-string">&quot;hacker&quot;</span>/&gt;<br>&lt;/form&gt;<br>&lt;script&gt;<span class="hljs-built_in">document</span>.forms[<span class="hljs-number">0</span>].submit();&lt;/script&gt; <br></code></pre></td></tr></table></figure><p>访问某页面后，该表单会自动提交，相当于模拟用户完成了一次POST操作。</p><p>POST类型的攻击通常比GET要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许POST上面。</p><p>&nbsp;</p><ul><li>链接类型的CSRF</li></ul><p>链接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。</p><p>这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;a href=<span class="hljs-string">&quot;http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker&quot;</span> taget=<span class="hljs-string">&quot;_blank&quot;</span>&gt;<br>   重磅消息！！<br>   &lt;a/&gt;<br></code></pre></td></tr></table></figure><p>由于之前用户登录了信任的网站A，并且保存登录状态，只要用户主动访问上面的这个PHP页面，则表示攻击成功。</p><hr><h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><p>一般而言，用户的每次请求都对应一个业务逻辑方法，并且每个业务逻辑方法往往具有逻辑上的原子性。</p><p>此外，一个业务逻辑方法往往包括一系列数据库原子访问操作，并且这些数据库原子访问操作应该绑定成一个整体，即要么全部执行，要么全部不执行，通过这种方式我们可以保证数据库的完整性，这就是事务。</p><p>总的来说，事务是一个不可分割操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。</p><h3 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h3><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作。</p><p>这两条SQL语句必须全部执行，或者，由于某些原因，如果第一条语句成功，第二条语句失败，就必须全部撤销。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">-- 从id=1的账户给id=2的账户转账100元<br>-- 第一步：将id=1的A账户余额减去100<br>UPDATE accounts SET balance = balance - 100 WHERE id = 1;<br>-- 第二步：将id=2的B账户余额加上100<br>UPDATE accounts SET balance = balance + 100 WHERE id = 2;<br></code></pre></td></tr></table></figure><p>这种把多条语句作为一个整体进行操作的功能，被称为数据库事务。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。</p><p>如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。</p><p>数据库事务具有ACID这4个特性：</p><ul><li>A：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；</li><li>C：Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；</li><li>I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；</li><li>D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。</li></ul><p>数据库系统有两种事务</p><ol><li><p>隐式事务: 对于单条SQL语句，数据库系统自动将其作为一个事务执行.</p></li><li><p>显式事务: 手动把多条SQL语句作为一个事务执行，使用BEGIN开启一个事务，使用COMMIT提交一个事务.</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">BEGIN;<br>UPDATE accounts SET balance = balance - 100 WHERE id = 1;<br>UPDATE accounts SET balance = balance + 100 WHERE id = 2;<br>COMMIT;<br><br></code></pre></td></tr></table></figure><p>COMMIT是指提交事务，即试图把事务内的所有SQL所做的修改永久保存。如果COMMIT语句执行失败了，整个事务也会失败。</p><p>有些时候，我们希望主动让事务失败，这时，可以用ROLLBACK回滚事务，整个事务会失败：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">BEGIN;<br>UPDATE accounts SET balance = balance - 100 WHERE id = 1;<br>UPDATE accounts SET balance = balance + 100 WHERE id = 2;<br>ROLLBACK;<br><br></code></pre></td></tr></table></figure><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，</p><p>数据库系统提供了隔离级别来让我们有针对性地选择事务的隔离级别，避免数据不一致的问题。</p><p>SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：</p><p>严格程度由低到高：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">Isolation Level  脏读（Dirty Read）   不可重复读（Non Repeatable Read）幻读（Phantom Read）<br>Read Uncommitted    Yes                 Yes                          Yes<br>Read Committed     -                 Yes                          Yes<br>Repeatable Read     -                  -                               Yes<br>Serializable     -                  -                                -<br></code></pre></td></tr></table></figure><h5 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h5><ul><li>脏读：</li></ul><p>读取未提交数据</p><p>A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。</p><ul><li>不可重复读：</li></ul><p>前后多次读取，数据内容不一致</p><p>事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间 。</p><p>而在事务A第一次读取数据，比如此时读取了小明的年龄为20岁，事务B执行更改操作，将小明的年龄更改为30岁，</p><p>此时事务A第二次读取到小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了</p><ul><li>幻读：</li></ul><p>前后多次读取，数据总量不一致</p><p>事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，</p><p>这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，成为幻读。</p><hr><h3 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h3><p>在使用传统的事务编程策略时，程序代码必然和具体的事务操作代码耦合</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">// JDBC事务<br>Connection conn = getConnection();<br>/关闭自动提交<br>conn.setAutoCommit(<span class="hljs-literal">false</span>);<br>...<br>// 业务实现<br>...<br><span class="hljs-keyword">if</span> 正常<br>    conn.commit();<br><span class="hljs-keyword">if</span> 失败<br>    conn.rollback();<br></code></pre></td></tr></table></figure><p>使用Spring事务管理策略恰好可以避免这种尴尬。Spring的事务管理提供了两种方式：</p><h4 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h4><p>Hibernate中，我们需要在代码中显式调用beginTransaction()、commit()、rollback()等事务管理相关的方法，</p><p>这就是编程式事务管理。通过 Spring 提供的事务管理 API，我们可以在代码中灵活控制事务的执行。在底层，Spring 仍然将事务操作委托给底层的持久化框架来执行。</p><ul><li>基于底层 API 的编程式事务管理</li></ul><p>基于PlatformTransactionManager、TransactionDefinition 和 TransactionStatus 三个核心接口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash">@Autowired<br>private PlatformTransactionManager txManager;<br><br>@Transactional<br>@PostMapping(<span class="hljs-string">&quot;/test/in2&quot;</span>)<br>public ResponseEntity&lt;String&gt; insertUser2(@RequestBody Map&lt;String, String&gt; params) throws RuntimeException&#123;<br><br>    String tel = params.get(<span class="hljs-string">&quot;tel&quot;</span>);<br>    // 1、创建事务定义<br>    TransactionDefinition definition = new DefaultTransactionDefinition();<br>    // 2、根据定义开启事务<br>    TransactionStatus status = txManager.getTransaction(definition);<br>    try &#123;<br>        //创建账号<br>        User user = new User();<br>        user.setName(tel);<br>        user.setTel(tel);<br>        user.setAddress(<span class="hljs-string">&quot;earth&quot;</span>);<br>        userMapper.insert(user);<br><br>        <span class="hljs-keyword">if</span>(tel.equals(<span class="hljs-string">&quot;rollback&quot;</span>))&#123;<br>            throw new RuntimeException(<span class="hljs-string">&quot;RollBack&quot;</span>);<br>        &#125;<br><br>        // 3、提交事务<br>        txManager.commit(status);<br>        <span class="hljs-built_in">return</span> ResponseEntity.ok(null);<br>    &#125; catch (Exception e) &#123;<br>        // 4、异常了，回滚事务<br>        txManager.rollback(status);<br>        throw e;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="声明式事务管理。"><a href="#声明式事务管理。" class="headerlink" title="声明式事务管理。"></a>声明式事务管理。</h4><p>Spring 的声明式事务管理是建立在 Spring AOP 机制之上的，其本质是对目标方法前后进行拦截，</p><p>并在目标方法开始之前创建或者加入一个事务， 在执行完目标方法之后根据执行情况提交或者回滚事务。</p><p>声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中作相关的事务规则声明（或通过等价的基于标注的方式），便可以将事务规则应用到业务逻辑中。</p><p><img src="img.png" alt="img.png"></p><p>总的来说，声明式事务得益于 Spring IoC容器 和 Spring AOP 机制的支持：IoC容器为声明式事务管理提供了基础设施，使得 Bean 对于 Spring 框架而言是可管理的；</p><p>而由于事务管理本身就是一个典型的横切逻辑（正是 AOP 的用武之地），因此 Spring AOP 机制是声明式事务管理的直接实现者。</p><p>显然，声明式事务管理要优于编程式事务管理，这正是spring倡导的非侵入式的开发方式。声明式事务管理使业务代码不受污染，一个普通的POJO对象，只要在XML文件中配置或者添加注解就可以获得完全的事务支持。</p><ul><li>使用 @Transactional</li></ul><p>自动配置一个 DataSourceTransactionManager，我们只需在方法（或者类）加上 @Transactional 注解，就自动纳入 Spring 的事务管理了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>@Autowired<br>DataSourceTransactionManager dataSourceTransactionManager;<br><br>@Transactional<br>    @PostMapping(<span class="hljs-string">&quot;/test/in&quot;</span>)<br>    public ResponseEntity&lt;String&gt; insertUser(@RequestBody Map&lt;String, String&gt; params) throws RuntimeException&#123;<br><br>        String tel = params.get(<span class="hljs-string">&quot;tel&quot;</span>);<br>        //创建账号<br>        User user = new User();<br>        user.setName(tel);<br>        user.setTel(tel);<br>        user.setAddress(<span class="hljs-string">&quot;earth&quot;</span>);<br>        userMapper.insert(user);<br><br>        <span class="hljs-keyword">if</span>(tel.equals(<span class="hljs-string">&quot;rollback&quot;</span>))&#123;<br>            throw new RuntimeException(<span class="hljs-string">&quot;RollBack&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">return</span> ResponseEntity.ok(null);<br>    &#125;<br></code></pre></td></tr></table></figure><p>@Transational方法是可以带参数的，具体的参数解释如下：</p><ul><li><p>propagation </p><p>  事务传播行为</p><p>  用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播。</p><ul><li>PROPAGATION_REQUIRED<br>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</li><li>PROPAGATION_SUPPORTS<br>支持当前事务，如果当前没有事务，就以非事务方式执行。</li><li>PROPAGATION_MANDATORY<br>使用当前的事务，如果当前没有事务，就抛出异常。</li><li>PROPAGATION_REQUIRES_NEW<br>新建事务，如果当前存在事务，把当前事务挂起。</li><li>PROPAGATION_NOT_SUPPORTED<br>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>PROPAGATION_NEVER<br>以非事务方式执行，如果当前存在事务，则抛出异常。</li><li>PROPAGATION_NESTED<br>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。  </li></ul></li></ul><ul><li><p>isolation</p><p>  事务隔离级别</p></li><li><p>readOnly</p><p>  事务的读写性，boolean型</p></li><li><p>timeout</p><p>  超时时间，int型，以秒为单位。</p></li><li><p>rollbackFor</p><p>  一组异常类，遇到时回滚。（rollbackFor={SQLException.class}）</p></li><li><p>rollbackForCalssName</p><p>  一组异常类名，遇到回滚，类型为 string[]</p></li><li><p>noRollbackFor</p><p>  一组异常类，遇到不回滚</p></li><li><p>norollbackForCalssName</p><p>  一组异常类名，遇到时不回滚。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://samsara98.gitee.io/samsara/&quot;&gt;SamsarA’s Blog&lt;/a&gt;! If you get any problems when reading my blog, you can&lt;br&gt;ask</summary>
      
    
    
    
    <category term="Study" scheme="https://wk1044481101.github.io/categories/Study/"/>
    
    
    <category term="-SpringBoot" scheme="https://wk1044481101.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS</title>
    <link href="https://wk1044481101.github.io/2021/05/16/HTTPS/"/>
    <id>https://wk1044481101.github.io/2021/05/16/HTTPS/</id>
    <published>2021-05-16T11:43:07.000Z</published>
    <updated>2021-07-01T09:57:53.375Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://samsara98.gitee.io/samsara/">SamsarA’s Blog</a>! If you get any problems when reading my blog, you can ask me on <a href="https://gitee.com/samsara98/samsara">Gitee</a>.</p><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><pre><code>#IP #TCP #UDP #HTTP</code></pre><p>&nbsp;  You can get source code on my <a href="https://gitee.com/samsara98/jerryrat">Gitee</a>.</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ol><li><p>HTTP 协议（HyperText Transfer Protocol，超文本传输协议）：是客户端浏览器或其他程序与Web服务器之间的应用层通信协议 。</p></li><li><p>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输。</p></li></ol><p>SSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。</p><p>TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。<br>HTTPS（全称：HyperText Transfer Protocol over Secure Socket Layer），<br>初衷是为了保证数据安全。</p><h2 id="HTTPS-1"><a href="#HTTPS-1" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTP请求过程中，客户端与服务器之间没有任何身份确认的过程，数据全部明文传输，“裸奔”在互联网上，所以很容易遭到黑客的攻击，<br>客户端发出的请求很容易被黑客截获，如果此时黑客冒充服务器，则其可返回任意信息给客户端，而不被客户端察觉，既为“劫持” ,<br>HTTP 传输面临的风险有：</p><ol><li><p>窃听风险：第三方可以获知通信内容。</p></li><li><p>篡改风险：第三方可以修改通信内容。</p></li><li><p>冒充风险：第三方可以冒充他人身份参与通信。</p></li></ol><p>SSL/TLS协议是为了解决这三大风险而设计的，希望达到：</p><ol><li><p>所有信息都是加密传播，第三方无法窃听。</p></li><li><p>具有校验机制，一旦被篡改，通信双方会立刻发现。</p></li><li><p>配备身份证书，防止身份被冒充。</p></li></ol><p>所谓加密，就是一个函数，它接收密码和明文，然后输出密文.</p><hr><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>使用对称加密的双方拥有相同的密钥，信息得到安全传输，但此种方式的缺点是：</p><p>常用算法有DES、AES和IDEA等；</p><p>密钥长度由算法设计决定，AES的密钥长度是128/192/256位；</p><p>使用对称加密算法需要指定算法名称、工作模式和填充模式。</p><p>密钥长度直接决定加密强度，而工作模式和填充模式可以看成是对称加密算法的参数和格式选择。</p><p>（1）不同的客户端、服务器数量庞大，所以双方都需要维护大量的密钥，维护成本很高</p><p>（2）因每个客户端、服务器的安全级别不同，密钥极易泄露</p><ul><li><p>口令加密：</p><p>  对称加密的口令，即用户输入的口令并不能直接作为AES的密钥进行加密（除非长度恰好是128/192/256位），并且用户输入的口令一般都有规律，</p><p>  安全性远远不如安全随机数产生的随机口令。因此，用户输入的口令，通常还需要使用PBE算法，采用随机数杂凑计算出真正的密钥，再进行加密。</p></li></ul><hr><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>公钥-私钥组成的密钥对是非常有用的加密方式，因为公钥是可以公开的，而私钥是完全保密的，由此奠定了非对称加密的基础。</p><p>非对称加密就是加密和解密使用的不是相同的密钥：只有同一个公钥-私钥对才能正常加解密。</p><p>客户端索取服务器端的公钥对请求内容加密，服务器使用自己的私钥对内容解密，反之亦然。</p><p>非对称加密相比对称加密的显著优点在于：</p><pre><code>对称加密需要协商密钥，多密钥管理难度大，而且非常容易泄漏。而非对称加密可以安全地公开各自的公钥</code></pre><p>上述过程也存在缺点：</p><pre><code>非对称加密的运算速度非常慢，比对称加密要慢很多。</code></pre><ul><li>密钥交换：</li></ul><p>对称加密算法解决了数据加密的问题。用户需要向服务器发送一个加密文件，可以先生成一个AES密钥，对文件进行加密，然后把加密文件发送给客户端。但是要解密，就必须需要密钥。</p><p>现在问题来了：如何传递密钥？</p><p>在不安全的信道上传递加密文件是没有问题的，因为黑客拿到加密文件没有用。但是，如何如何在不安全的信道上安全地传输密钥？</p><p>要解决这个问题，密钥交换算法即DH算法：Diffie-Hellman算法应运而生。</p><p>DH算法是一个密钥协商算法，双方最终协商出一个共同的密钥，而这个密钥不会通过网络传输。</p><hr><h3 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h3><p>实际应用的时候，非对称加密总是和对称加密一起使用。<br>因为非对称加密计算量太大，因此服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。<br>客户端需要给服务器传输加密文件，首先交换了各自的公钥，然后：</p><pre><code>1. 客户端生成一个随机的对话密钥，使用服务器的公钥通过加密这个口令，并发送给客户端；2. 服务器用自己的私钥解密得到对话密钥；3. 双方使用这个共享的对话密钥加密通信。</code></pre><ul><li>如何保证公钥不被篡改：</li></ul><p>将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p><hr><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><ul><li><p>摘要算法用来确保数据没有被篡改。</p></li><li><p>非对称加密算法可以对数据进行加解密。</p></li><li><p>签名算法可以确保数据完整性和抗否认性。</p></li></ul><p>把这些算法集合到一起，并搞一套完善的标准，这就是数字证书。</p><p>因此，数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准。</p><p>数字证书可以防止中间人攻击，因为它采用链式签名认证，即通过根证书（Root CA）去签名下一级证书，这样层层签名，直到最终的用户证书。而Root CA证书内置于操作系统中，所以，任何经过CA认证的数字证书都可以对其本身进行校验，确保证书本身不是伪造的。</p><p>要使用数字证书，首先需要创建证书。正常情况下，一个合法的数字证书需要经过CA签名，这需要认证域名并支付一定的费用。</p><ul><li>HTTPS协议:</li></ul><p>浏览器和服务器建立安全连接的步骤如下：</p><ol><li><p>浏览器向服务器发起请求，服务器向浏览器发送自己的数字证书；</p></li><li><p>浏览器用操作系统内置的Root CA来验证服务器的证书是否有效，如果有效，就使用该证书加密一个随机的AES口令并发送给服务器；</p></li><li><p>服务器用自己的私钥解密获得AES口令，并在后续通讯中使用AES加密。</p></li></ol><hr><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>使用非对称加密算法的时候，对于一个公钥-私钥对，通常是用公钥加密，私钥解密。</p><p>如果反过来使用私钥加密，公钥解密是否可行呢？</p><p>私钥加密得到的密文实际上就是数字签名，要验证这个签名是否正确，只能用私钥持有者的公钥进行解密验证。使用数字签名的目的是为了确认某个信息确实是由某个发送方发送的，任何人都不可能伪造消息，并且，发送方也不能抵赖。</p><p>在实际应用的时候，签名实际上并不是针对原始消息，而是针对原始消息的哈希进行签名。</p><p>在网站上下载软件的时候，经常看到下载页显示的哈希，如何判断下载到本地的软件是原始的、未经篡改的文件？</p><p>我们只需要自己计算一下本地文件的哈希值，再与官网公开的哈希值对比，如果相同，说明文件下载正确，否则，说明文件已被篡改。</p><p>数字签名用于：</p><ul><li>防止伪造</li><li>防止抵赖</li><li>检测篡改</li></ul><h2 id="握手阶段"><a href="#握手阶段" class="headerlink" title="握手阶段"></a>握手阶段</h2><h3 id="客户端发出请求"><a href="#客户端发出请求" class="headerlink" title="客户端发出请求"></a>客户端发出请求</h3><p>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。</p><p>在这一步，客户端主要向服务器提供以下信息。</p><pre><code>（1） 支持的协议版本，比如TLS 1.0版。（2） 一个客户端生成的随机数，稍后用于生成&quot;对话密钥&quot;。（3） 支持的加密方法，比如RSA公钥加密。（4） 支持的压缩方法。</code></pre><h3 id="服务器回应"><a href="#服务器回应" class="headerlink" title="服务器回应"></a>服务器回应</h3><p>服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。</p><pre><code>（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。（2） 一个服务器生成的随机数，稍后用于生成&quot;对话密钥&quot;。（3） 确认使用的加密方法，比如RSA公钥加密。（4） 服务器证书。</code></pre><h3 id="客户端回应"><a href="#客户端回应" class="headerlink" title="客户端回应"></a>客户端回应</h3><p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p><p>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。</p><pre><code>（1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。（2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。（3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</code></pre><h3 id="服务器的最后回应"><a href="#服务器的最后回应" class="headerlink" title="服务器的最后回应"></a>服务器的最后回应</h3><p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。</p><pre><code>（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</code></pre><p>整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://samsara98.gitee.io/samsara/&quot;&gt;SamsarA’s Blog&lt;/a&gt;! If you get any problems when reading my blog, you can ask me</summary>
      
    
    
    
    <category term="Study" scheme="https://wk1044481101.github.io/categories/Study/"/>
    
    
    <category term="TCP/IP" scheme="https://wk1044481101.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>IOC</title>
    <link href="https://wk1044481101.github.io/2021/05/06/IOC/"/>
    <id>https://wk1044481101.github.io/2021/05/06/IOC/</id>
    <published>2021-05-06T07:18:41.000Z</published>
    <updated>2021-07-01T09:54:13.303Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>Welcome to <a href="https://samsara98.gitee.io/samsara/">SamsarA’s Blog</a>! If you get any problems when reading my blog, you can ask me on <a href="https://gitee.com/samsara98/samsara">Gitee</a>.</p><h1 id="Html3"><a href="#Html3" class="headerlink" title="Html3"></a>Html3</h1><pre><code>#SpringBoot #Mybatis #MySql</code></pre><p>&nbsp;  You can get source code on my <a href="https://gitee.com/samsara98/adabank3_maven">Gitee</a>.</p><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>控制反转（Inversion of Control）是一个重要的面向对象编程的法则来削减计算机程序的耦合问题。<br>它还有一个名字叫做依赖注入（Dependency Injection）。<br>IoC不是什么技术，它是一种设计模式。通俗理解就是将接口的具体实现类的控制权从调用类中分离转交给第三方决定。<br>在 Spring 中有专门的一个容器来创建和管理这些对象，并将对象依赖的其他对象注入到该对象中，这个容器我们一般称为 IoC 容器。<br>IOC和DI描述的是一件事情，只是从不同的角度来描述：</p><ul><li><p>IOC控制反转：说的是创建对象实例的控制权从代码控制剥离到IOC容器控制，实际上就是我们现在说的第三方，侧重于原理。</p></li><li><p>DI依赖注入：说的是创建对象实例时，为这个对象注入属性值或其它对象实例，侧重于实现。</p></li></ul><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p><img src="https://res-static.hc-cdn.cn/fms/img/3651aef9138be99f781776fa0cd8e0f91603448355382.png"><br>BeanFactory作为最顶层的一个接口类,它定义了IOC容器的基本功能规范，<br>BeanFactory里面只对IOC容器最基本的行为做了定义，而不关心Bean是怎样定义和加载的。</p><p>如果我们想要知道一个工厂具体生产对象的过程，就需要去看这个接口的实现类。 我们可以发现最终的默认实现类是 DefaultListableBeanFactory，他实现了所有的接口。</p><p>BeanFactory 有三个子类：ListableBeanFactory、HierarchicalBeanFactory 和AutowireCapableBeanFactory。</p><p>为何要定义这么多层次的接口呢？查阅这些接口的源码和说明发现，每个接口都有他使用的场合。<br>它主要是为了区分在 Spring 内部在操作过程中对象的传递和转化过程中，对对象的数据访问所做的限制。<br>例如 ListableBeanFactory 接口表示这些 Bean 是可列表的，而 HierarchicalBeanFactory 表示的是这些 Bean 是有继承关系的，也就是每个Bean 有可能有父 Bean。AutowireCapableBeanFactory 接口定义 Bean 的自动装配规则。这四个接口共同定义了 Bean 的集合、Bean 之间的关系、以及 Bean 行为.</p><p>IoC 在 Spring 里，只需要低级容器（BeanFactory）就可以实现，两个步骤：</p><ol><li>加载配置文件，解析成 BeanDefinition 放在 Map 里。</li><li>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</li></ol><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>一般情况下，我们将 bean 的创建和管理都交给 Spring IoC 容器，Spring 会利用 bean 的 class 属性指定的类来实例化 bean。</p><p>但是如果我们想自己实现 bean 的创建操作，FactoryBean 就可以实现这个需求。</p><p>FactoryBean 是一种特殊的 bean，它是个工厂 bean，可以自己创建 bean 实例，如果一个类实现了 FactoryBean 接口，则该类可以自己定义创建实例对象的方法，只需要实现它的 getObject() 方法即可。</p><h3 id="Beandefinition"><a href="#Beandefinition" class="headerlink" title="Beandefinition"></a>Beandefinition</h3><p>在 Spring 中，构成应用程序主干并由 Spring IoC 容器管理的对象称为 bean。<br>bean 是一个由 Spring IoC 容器实例化，组装和管理的对象。</p><p>Bean对象在Spring实现中是以BeanDefinition来描述的,用来存储 bean 的所有属性方法定义。<br>对loC容器来说，它为管理POJO之间的依赖关系提供了帮助，但也要依据Spring的定义规则提供Bean定义信息。</p><p>我们可以使用各种形式的Bean定义信息。</p><ul><li><p>方法一：基于XML的bean定义（需要提供setter方法）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;test.Student&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;a&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;teacher&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;test.Teacher&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;b&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br> <br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>方法二：基于注解的bean定义（不需要提供setter方法）</p><p>Spring为此提供了注解，这些注解的作用与XML定义bean效果一致，在于将组件交给Spring容器管理。组件的名称默认是类名（首字母变小写），也可以自己修改： </p></li></ul><ol><li>@Component：当对组件的层次难以定位的时候使用这个注解</li><li>@Controller：表示控制层的组件</li><li>@Service：表示业务逻辑层的组件，相当于告诉 IoC 容器：这个类你需要帮我创建和管理</li><li>@Repository：表示数据访问层的组件</li><li>@AutoWire：相当于告诉 IoC 容器：我需要依赖这个类，你需要帮我注入进来。</li></ol><ul><li>基于Java类的bean定义（需要提供setter方法）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">@Configuration<br>public class BeansConfiguration &#123;<br> <br>    @Bean<br>    public Student <span class="hljs-function"><span class="hljs-title">student</span></span>()&#123;<br>        Student student=new Student();<br>        student.setName(<span class="hljs-string">&quot;a&quot;</span>);<br>        student.setTeacher(teacher());<br>        <span class="hljs-built_in">return</span> student;<br>    &#125;<br> <br>    @Bean<br>    public Teacher <span class="hljs-function"><span class="hljs-title">teacher</span></span>()&#123;<br>        Teacher teacher=new Teacher();<br>        teacher.setName(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-built_in">return</span> teacher;<br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BeandefinitionReader"><a href="#BeandefinitionReader" class="headerlink" title="BeandefinitionReader"></a>BeandefinitionReader</h3>Bean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。<br>Bean 的解析主要就是对 Spring 配置文件的解析。<h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3>ApplicationContext：BeanFactory 的子接口，在 BeanFactory 的基础上构建，是相对比较高级的 IoC 容器实现。包含 BeanFactory 的所有功能.</li></ul><p>除了能够提供IoC容器的基本功能外，还为用户提供了以下的附加服务。</p><ol><li>支持不同的倌息源。我们看到ApplicationContext扩展了MessageSource接口，这些信息源的扩展功能可以支持国际化的实现，为开发多语言版本的应用提供服务。</li><li>访问资源。这一特性体现在对ResourceLoader和Resource的支持上，这样我们可以从不同地方得到Bean定义资源。这种抽象使用户程序可以灵活地定义Bean定义信息，尤其是从不同的途径得到Bean定义信息。这在接口关系上看不出来，不过一般来说，具体ApplicationContext都是继承了DefaultResourceLoader的子类。因为DefaultResourceLoader是AbstractApplicationContext的基类，关于Resource在loC容器中的使用，后面会有详细的讲解。</li><li>支持应用事件。继承了接口ApplicationEventPublisber,从而在上下文中引入了事件机制。这些事件和Bean的生命周期的结合为Bean的管理提供了便利。</li><li>在ApplicationContext中提供的附加服务。这些服务使得基本IoC容器的功能更丰富。因为具备了这些丰富的附加功能，使得ApplicationContext与简单的BeanFactory相比，对它的使用是一种面向框架的使用风格，所以一般建议在开发应用时使用ApplicationContext作为IoC容器的基本形式。</li></ol><h2 id="Spring-IoC核心流程"><a href="#Spring-IoC核心流程" class="headerlink" title="Spring IoC核心流程"></a>Spring IoC核心流程</h2><p>IoC容器的初始化包括BeanDefinition的Resource定位、载入和注册这三个基本的过程：</p><ol><li>创建Ioc配置文件的抽象资源，这个抽象资源包含了BeanDefinition的定义信息</li><li>创建一个BeanFactory，可以使用DefaultListableBeanFactory,根据配置的路径，读取 Spring 配置文件，并封装成 Resource</li><li>创建一个载入BeanDefinition的读取器，可以使用XmlBeanDefinitionReader来载入XML文件形式的BeanDefinition</li><li>然后将上面定位好的Resource，通过一个回调配置给BeanFactory</li><li>从定位好的资源位置读入配置信息，具体的解析过程由XmlBeanDefinitionReader完成</li><li>完成整个载入和注册Bean定义之后，需要的Ioc容器就初步建立起来了</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;Welcome to &lt;a href=&quot;https://samsara98.gitee.io/samsara/&quot;&gt;SamsarA’s Blog&lt;/a&gt;! If you get any problems when reading my b</summary>
      
    
    
    
    <category term="Study" scheme="https://wk1044481101.github.io/categories/Study/"/>
    
    
    <category term="-HTML" scheme="https://wk1044481101.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://wk1044481101.github.io/2021/04/27/hello-world/"/>
    <id>https://wk1044481101.github.io/2021/04/27/hello-world/</id>
    <published>2021-04-27T06:06:19.021Z</published>
    <updated>2021-04-27T06:06:19.021Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CSS_JS_HTML</title>
    <link href="https://wk1044481101.github.io/2021/04/19/HTML/"/>
    <id>https://wk1044481101.github.io/2021/04/19/HTML/</id>
    <published>2021-04-19T10:19:40.000Z</published>
    <updated>2021-07-01T09:57:53.363Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://samsara98.gitee.io/samsara/">SamsarA’s Blog</a>! If you get any problems when reading my blog, you can<br>ask me on <a href="https://gitee.com/samsara98/samsara">Gitee</a>.</p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><pre><code>#Vue  #JavaScript  #JSX  #React</code></pre><p>&nbsp; You can get source code on my <a href="https://gitee.com/samsara98/">Gitee</a>.</p><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>React 是一个用于构建用户界面的 JAVASCRIPT 库</p><ul><li><p>React 特点:</p><p>1.声明式设计 −React采用声明范式，可以轻松描述应用。</p><p>2.高效 −React通过对DOM的模拟，最大限度地减少与DOM的交互。</p><p>3.灵活 −React可以与已知的库或框架很好地配合。</p><p>4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。</p><p>5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。</p><p>6.单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。</p></li></ul><h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><p>元素是构成 React 应用的最小单位，它用于描述屏幕上输出的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br></code></pre></td></tr></table></figure><p>这种标签语法标签语法既不是字符串也不是 HTML，名为JSX， 一种 JavaScript 的语法扩展。</p><p>因为JSX的特性更接近JavaScript而不是HTML，所以React<br>DOM使用camelCase（小驼峰）命名来定义属性的名称，而不是使用HTML的属性名称。例如：class变成了className，而tableindex则对应着tableIndex。</p><p>JSX语法：</p><ul><li>JSX可以使用引号来定义以字符串为值的属性：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">tabIndex</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br></code></pre></td></tr></table></figure><ul><li>也可以使用大括号来定义以JavaScript表达式为值的属性：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;user.Url&#125;</span> /&gt;</span></span>;<br></code></pre></td></tr></table></figure><ul><li>在JSX中可任意使用JavaScript表达式，但要包含在大括号里。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatName</span>(<span class="hljs-params">user</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> user.firstName + <span class="hljs-string">&#x27; &#x27;</span> + user.lastName;<br>&#125;<br><span class="hljs-keyword">const</span> user = &#123;<br>    firstName: <span class="hljs-string">&#x27;Harper&#x27;</span>,<br>    lastName: <span class="hljs-string">&#x27;Perez&#x27;</span><br>&#125;;<br><span class="hljs-keyword">const</span> element = (<br>    &lt;h1&gt;<br>        Hello, &#123;formatName(user)&#125;!<br>    &lt;/h1&gt;<br>);<br>ReactDOM.render(<br>    element,<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><ul><li>JSX本身其实也是一种表达式</li></ul><p>在编译之后，JSX会被转化为普通的JavaScript对象。所以可以在if或者for语句里使用JSX，将它赋值给变量，当作参数传入，作为返回值都是允许的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (bool) &#123;<br> element = &lt;div&gt;<br>                &lt;Name name=<span class="hljs-string">&quot;GET&quot;</span>/&gt;<br>                &lt;Url source=<span class="hljs-string">&quot;https://gitee.com/api/v5/users/samsara98/events/public&quot;</span>/&gt;<br>            &lt;/div&gt;;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br> element = &lt;div&gt;<br>                &lt;State state=<span class="hljs-string">&quot;关闭&quot;</span>/&gt;<br>            &lt;/div&gt;;<br>        &#125;<br></code></pre></td></tr></table></figure><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ol><li>使用函数定义了一个组件： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">HelloMessage</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;   <br></code></pre></td></tr></table></figure></li><li>使用 ES6 class 来定义一个组件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Welcome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>原生 HTML 元素名以小写字母开头，而自定义的 React 类名以大写字母开头，比如 HelloMessage 不能写成 helloMessage。除此之外还需要注意组件类只能包含一个顶层标签，否则也会报错。 </p><ul><li>复合组件<br>我们可以通过创建多个组件来合成一个组件，即把组件的不同功能点进行分离。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Name</span>(<span class="hljs-params">props</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>*&#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Url</span>(<span class="hljs-params">props</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>[&#123;props.source&#125;]<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">State</span>(<span class="hljs-params">props</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>-&#123;props.state&#125;-<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">var</span> element = &lt;div&gt;<br>                &lt;Name name=<span class="hljs-string">&quot;GET&quot;</span>/&gt;<br>                &lt;Url source=<span class="hljs-string">&quot;https://gitee.com/api/v5/users/samsara98/events/public&quot;</span>/&gt;<br>            &lt;/div&gt;;<br><br></code></pre></td></tr></table></figure></li></ul><p>###State/Props</p><p>React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。</p><p>React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。</p><p>添加一个类构造函数来初始化状态 this.state，类组件应始终使用 props 调用基础构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserGist</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;url&#x27;</span>, <span class="hljs-attr">repoName</span>: <span class="hljs-string">&#x27;repoName&#x27;</span>, <span class="hljs-attr">repoUrl</span>: <span class="hljs-string">&#x27;repoUrl&#x27;</span>, <span class="hljs-attr">date</span>: <span class="hljs-string">&#x27;date&#x27;</span>&#125;;<br>    &#125;<br>    ...;<br>    ...;<br>&#125;<br>ReactDOM.render(<br>    &lt;UserGist<br>        source=<span class="hljs-string">&quot;https://gitee.com/api/v5/users/samsara98/events/public?access_token=b56b13c24f26013f779d98f875beccf5&amp;limit=20 &quot;</span>/&gt;,<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;example2&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><ul><li>这里的source就是一个props，通过this.props.source调用  </li><li>{name: ‘name’, url: ‘url’, repoName: ‘repoName’, repoUrl: ‘repoUrl’, date: ‘date’}则为state<br>通过this.state.name调用</li><li>state 和 props 主要的区别在于 props 是不可变的，而 state 可以根据与用户交互来改变。</li></ul><h3 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h3><p>组件的生命周期可分成三个状态：</p><ul><li>Mounting：已插入真实 DOM</li><li>Updating：正在被重新渲染</li><li>Unmounting：已移出真实 DOM</li></ul><p>生命周期的方法有：</p><pre><code>componentWillMount 在渲染前调用,在客户端也在服务端。componentDidMount : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异步操作阻塞UI)。componentWillReceiveProps 在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。shouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。可以在你确认不需要更新组件时使用。componentWillUpdate在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用。componentWillUnmount在组件从 DOM 中移除之前立刻被调用。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://samsara98.gitee.io/samsara/&quot;&gt;SamsarA’s Blog&lt;/a&gt;! If you get any problems when reading my blog, you can&lt;br&gt;ask</summary>
      
    
    
    
    <category term="Study" scheme="https://wk1044481101.github.io/categories/Study/"/>
    
    
    <category term="-HTML" scheme="https://wk1044481101.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>DOM_Parse_Enum</title>
    <link href="https://wk1044481101.github.io/2021/04/09/DOM_Parse_Enum/"/>
    <id>https://wk1044481101.github.io/2021/04/09/DOM_Parse_Enum/</id>
    <published>2021-04-09T05:55:23.000Z</published>
    <updated>2021-07-01T09:57:53.371Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://samsara98.gitee.io/samsara/">SamsarA’s Blog</a>! If you get any problems when reading my blog, you can<br>ask me on <a href="https://gitee.com/samsara98/samsara">Gitee</a>.</p><h1 id="DOM-Parse-Enum"><a href="#DOM-Parse-Enum" class="headerlink" title="DOM_Parse_Enum"></a>DOM_Parse_Enum</h1><pre><code>#HTML #CSS #Parse #Dom #Enum</code></pre><ul><li>Let’s build a browser engine!</li></ul><p>&nbsp; You can get source code on my <a href="https://gitee.com/samsara98/firekaka">Gitee</a>.</p><hr><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM 是Document Object Model( 文档对象模型 )的缩写，是把html里面 的各种数据当作对象进行操作的一种思路。当创建好一个页面并加载到浏览器时，<br>DOM就悄然而生，它会把网页文档转换为一个文档对象，主要功能是处理网页内容。 在这个文档对象里，所有的元素呈现出一种层次结构.</p><p>DOM把所有的html都转换为节点</p><ul><li>整个html是一个节点</li><li>元素(div,span)是节点</li><li>元素属性(class,id)是节点</li><li>元素内容是节点</li><li>注释也是节点<br><img src="https://www.runoob.com/wp-content/uploads/2013/09/ct_htmltree.gif"></li></ul><hr><h2 id="浏览器绘制html的过程"><a href="#浏览器绘制html的过程" class="headerlink" title="浏览器绘制html的过程"></a>浏览器绘制html的过程</h2><h3 id="解析HTML为DomNode"><a href="#解析HTML为DomNode" class="headerlink" title="解析HTML为DomNode"></a>解析HTML为DomNode</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">DomNode对象: 由html内容解析生成，分为两种ElementNode、TextNode<br>    <br>    ElementNode： 元素节点，包含标签名tagName，属性对attrs以及该节点的子节点列表children<br>    <br>    TextNode： 文本节点，无标签名，只包含文本内容。<br></code></pre></td></tr></table></figure><h3 id="解析CSS为Stylesheet"><a href="#解析CSS为Stylesheet" class="headerlink" title="解析CSS为Stylesheet"></a>解析CSS为Stylesheet</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">Stylesheet: 由CSS文件解析,包含多个Rule.   <br>    <br>    Rule: 包含选择器列表selectors以及CSS描述内容列表declarations.<br>        Selector: 选择器对象，可能包含下面三者中至少一个-&gt;选择标签：tagName，选择ID：id，选择类：className。<br>        Declaration: CSS描述对象，包含描述的key和value。<br></code></pre></td></tr></table></figure><h3 id="由DomNode和Stylesheet生成StyleNode"><a href="#由DomNode和Stylesheet生成StyleNode" class="headerlink" title="由DomNode和Stylesheet生成StyleNode"></a>由DomNode和Stylesheet生成StyleNode</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">StyledNode: DomNode和Stylesheet中的规则根据优先级进行匹配生成，包含其对应的DomNode节点、该节点对应的标签属性propertyMap以及子节点列表列表children。<br>   <br>MatchedRule： 包含一条规则Rule以及该规则选择器的优先级，用于匹配。<br></code></pre></td></tr></table></figure><h3 id="由StyleNode生成LayoutBox布局树"><a href="#由StyleNode生成LayoutBox布局树" class="headerlink" title="由StyleNode生成LayoutBox布局树"></a>由StyleNode生成LayoutBox布局树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">LayoutBox：由StyleNode的属性计算得到，包含盒子的位置、大小Dimensions、盒子的种类BoxType、盒子的子盒子children。<br> <br>    Dimensions：包含盒子的位置和内容大小content，盒子的边界情况padding、border、margin。<br>    <br>    Rect： 描述一个盒子，包含盒子的位置x、y，盒子的宽高：width、height。<br>    <br>    EdgeSize： 描述盒子的边界情况，包含左右上下距离left、right、top、bottom。<br>    <br>    Type： 枚举类型，盒子有四种类型BlockNode, InlineNode, AnonymousBlock,none。       <br>        BlockNode：块级元素，宽度取决于父类盒子宽度，高度取决于子盒子的总高度。<br>        InlineNod：内联元素，宽度取决于盒子宽度。<br>        AnonymousBlock： 匿名盒子，用于分隔block和inline<br>        none： 无样式。<br></code></pre></td></tr></table></figure><h3 id="根据布局树绘制html页面"><a href="#根据布局树绘制html页面" class="headerlink" title="根据布局树绘制html页面"></a>根据布局树绘制html页面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">Paint：根据布局树LayoutBox构建显示列表displayList，分别处理显示命令DispalyCommand，返回一个画布Canvas<br><br>DispalyCommand-&gt;SolidType： 一个布局显示命令，包含命令名：commandName，绘制范围rect，以及绘制颜色Type。<br><br>Canvas： 包含需要绘制的画布宽、高：width，height以及填充画布的像素列表pixels。<br></code></pre></td></tr></table></figure><hr><h2 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h2><h3 id="枚举的定义"><a href="#枚举的定义" class="headerlink" title="枚举的定义"></a>枚举的定义</h3><ul><li>枚举类型一种特殊的数据类型，它既是一种类(class)类型却又比类类型多了些特殊的约束。</li></ul><p>在没有枚举类型时定义常量常见的方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class DayDemo &#123;<br><br>    public static final int BlockNode =1;<br><br>    public static final int InlineNode=2;<br><br>    public static final int AnonymousBlock=3;<br><br>    public static final int None=4;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述的常量定义常量的方式称为int枚举模式，这样的定义方式并没有什么错，<br>但它存在许多不足，如在类型安全和使用方便性上并没有多少好处，<br>如果存在定义int值相同的变量，混淆的几率还是很大的，<br>编译器也不会提出任何警告，因此这种方式在枚举出现后并不提倡，<br>现在我们利用枚举类型来重新定义上述的常量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">public enum Type &#123;<br>    BlockNode(<span class="hljs-string">&quot;block&quot;</span>,1), InlineNode(<span class="hljs-string">&quot;inline&quot;</span>,2), AnonymousBlock(<span class="hljs-string">&quot;anonymous&quot;</span>,3), None(<span class="hljs-string">&quot;none&quot;</span>,4);<br><br>    private final String <span class="hljs-built_in">type</span>;<br>    <br>    private final int i;<br><br>    private Type(String <span class="hljs-built_in">type</span>,int i) &#123;<br>        this.type = <span class="hljs-built_in">type</span>;<br>        this.i = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在定义枚举类型时我们使用的关键字是enum，与class关键字类似，<br>只不过前者是定义枚举类型，后者是定义类类型。值一般是大写的字母，多个值之间以逗号分隔。</p><p>同时我们应该知道的是枚举类型可以像类(class)类型一样，定义为一个单独的文件，当然也可以定义在其他类内部，<br>更重要的是枚举常量在类型安全性和便捷性都很有保证，如果出现类型问题编译器也会提示我们改进，<br>但务必记住枚举表示的类型其取值是必须有限的，也就是说每个值都是可以枚举出来的。</p><h3 id="枚举实现原理"><a href="#枚举实现原理" class="headerlink" title="枚举实现原理"></a>枚举实现原理</h3><p>Java Enum类型的语法结构尽管和java类的语法不一样，应该说差别比较大。 但是经过编译器编译之后产生的是一个class文件。 该class文件经过反编译可以看到实际上是生成了一个类， 该类继承了java.lang.Enum<E>。</p><p>而且枚举类是一个不可以被继承的final类。其枚举值(BlockNode,InlineNode…)都是Type类型的类静态常量，因此枚举类中的枚举值最好全部大写。</p><p>我们可以通过下面的方式来得到Type枚举类的一个实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">Type type&#x3D;Type.BlockNode;<br></code></pre></td></tr></table></figure><p>经过反编译(javap Type命令)之后得到的内容大致如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">//反编译Type.class<br>public final class Type extends java.lang.Enum&#123; <br>  //前面定义的枚举实例<br>    public static final WeekDay BlockNode; <br>    public static final WeekDay InlineNode; <br>    public static final WeekDay AnonymousBlock; <br>    public static final WeekDay None; <br>    static &#123;<br>      //实例化枚举实例<br>      BlockNode = new Type(<span class="hljs-string">&quot;block&quot;</span>,1);<br>      ...<br>      ...<br>    &#125;; <br>    <br>     //私有构造函数<br>    private Type(String <span class="hljs-built_in">type</span>) &#123;...&#125;<br>    <br>    //编译器为我们添加的静态的valueOf()方法，注意间接调用了Enum类的valueOf方法<br>    public static Type[] <span class="hljs-function"><span class="hljs-title">values</span></span>()&#123;...&#125;; <br>    <br>    //编译器为我们添加的静态的values()方法<br>    public static Type valueOf(java.lang.String)&#123;...&#125;; <br>&#125;<br></code></pre></td></tr></table></figure><p>即然枚举类是class，当然在枚举类型中有构造器，方法和数据域。但是，枚举类的构造器有很大的不同：</p><ul><li>(1) 构造器只是在构造枚举值的时候被调用。</li><li>(2) 构造器只能私有private，绝对不允许有public构造器。 这样可以保证外部代码无法新构造枚举类的实例。</li></ul><h3 id="Enum抽象类常见方法"><a href="#Enum抽象类常见方法" class="headerlink" title="Enum抽象类常见方法"></a>Enum抽象类常见方法</h3><p>Enum是所有 Java 语言枚举类型的公共基本类（注意Enum是抽象类），以下是它的常见方法：</p><ul><li>ordinal()方法: 返回枚举值在枚举类种的顺序。这个顺序根据枚举值声明的顺序而定。   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;返回类型：int<br>Type.BlockNode.ordinal();  &#x2F;&#x2F;返回结果：0<br>Type.InlineNode.ordinal();  &#x2F;&#x2F;返回结果：1<br></code></pre></td></tr></table></figure></li><li>compareTo()方法: Enum实现了java.lang.Comparable接口，因此可以比较象与指定对象的顺序。Enum中的compareTo返回的是两个枚举值的顺序之差。当然，前提是两个枚举值必须属于同一个枚举类，否则会抛出ClassCastException()异常。(具体可见源代码)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;返回类型：int<br>Type.BlockNode.compareTo(Type.InlineNode);  &#x2F;&#x2F;返回结果 -1<br></code></pre></td></tr></table></figure></li><li>values()方法： 静态方法，返回一个包含全部枚举值的数组。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">Type[] Types&#x3D;Type.values();<br>for(Type c:Types)&#123;<br>  System.out.print(c+&quot;,&quot;);<br>&#125;&#x2F;&#x2F;返回结果：BlockNode,InlineNode,AnonymousBlock,None<br></code></pre></td></tr></table></figure></li><li>toString()方法： 返回枚举常量的名称。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;返回类型：String<br>Type type&#x3D;Type.BlockNode;<br>System.out.println(type);&#x2F;&#x2F;返回结果: BlockNode<br></code></pre></td></tr></table></figure></li><li>valueOf()方法： 这个方法和toString方法是相对应的，返回带指定名称的指定枚举类型的枚举常量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;返回类型：static&lt;T extends Enum&lt;T&gt;&gt; T<br>Type.valueOf(&quot;block&quot;);   <br>&#x2F;&#x2F;返回结果: Type.BlockNode<br></code></pre></td></tr></table></figure></li><li>equals()方法： 比较两个枚举类对象的引用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;返回类型： boolean<br>Type.BlockNode.equals(Type.InlineNode) &#x2F;&#x2F;返回结果: false<br></code></pre></td></tr></table></figure></li><li>getDeclaringClass()方法： 返回与此枚举常量的枚举类型相对应的 Class 对象</li><li>name()方法： 返回此枚举常量的名称，在其枚举声明中对其进行声明</li></ul><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>Enum类内部会有一个构造函数，该构造函数只能有编译器调用，我们是无法手动操作的，不妨看看Enum类的主要源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs bash">//实现了Comparable<br>public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt;<br>        implements Comparable&lt;E&gt;, Serializable &#123;<br><br>    private final String name; //枚举字符串名称<br><br>    public final String <span class="hljs-function"><span class="hljs-title">name</span></span>() &#123;<br>        <span class="hljs-built_in">return</span> name;<br>    &#125;<br><br>    private final int ordinal;//枚举顺序值<br><br>    public final int <span class="hljs-function"><span class="hljs-title">ordinal</span></span>() &#123;<br>        <span class="hljs-built_in">return</span> ordinal;<br>    &#125;<br><br>    //枚举的构造方法，只能由编译器调用<br>    protected Enum(String name, int ordinal) &#123;<br>        this.name = name;<br>        this.ordinal = ordinal;<br>    &#125;<br><br>    public String <span class="hljs-function"><span class="hljs-title">toString</span></span>() &#123;<br>        <span class="hljs-built_in">return</span> name;<br>    &#125;<br><br>    public final boolean equals(Object other) &#123;<br>        <span class="hljs-built_in">return</span> this==other;<br>    &#125;<br><br>    //比较的是ordinal值<br>    public final int compareTo(E o) &#123;<br>        Enum&lt;?&gt; other = (Enum&lt;?&gt;)o;<br>        Enum&lt;E&gt; self = this;<br>        <span class="hljs-keyword">if</span> (self.getClass() != other.getClass() &amp;&amp; // optimization<br>            self.getDeclaringClass() != other.getDeclaringClass())<br>            throw new ClassCastException();<br>        <span class="hljs-built_in">return</span> self.ordinal - other.ordinal;//根据ordinal值比较大小<br>    &#125;<br><br>    @SuppressWarnings(<span class="hljs-string">&quot;unchecked&quot;</span>)<br>    public final Class&lt;E&gt; <span class="hljs-function"><span class="hljs-title">getDeclaringClass</span></span>() &#123;<br>        //获取class对象引用，getClass()是Object的方法<br>        Class&lt;?&gt; clazz = getClass();<br>        //获取父类Class对象引用<br>        Class&lt;?&gt; zuper = clazz.getSuperclass();<br>        <span class="hljs-built_in">return</span> (zuper == Enum.class) ? (Class&lt;E&gt;)clazz : (Class&lt;E&gt;)zuper;<br>    &#125;<br><br><br>    public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType,<br>                                                String name) &#123;<br>        //enumType.enumConstantDirectory()获取到的是一个map集合，key值就是name值，value则是枚举变量值   <br>        //enumConstantDirectory是class对象内部的方法，根据class对象获取一个map集合的值       <br>        T result = enumType.enumConstantDirectory().get(name);<br>        <span class="hljs-keyword">if</span> (result != null)<br>            <span class="hljs-built_in">return</span> result;<br>        <span class="hljs-keyword">if</span> (name == null)<br>            throw new NullPointerException(<span class="hljs-string">&quot;Name is null&quot;</span>);<br>        throw new IllegalArgumentException(<br>            <span class="hljs-string">&quot;No enum constant &quot;</span> + enumType.getCanonicalName() + <span class="hljs-string">&quot;.&quot;</span> + name);<br>    &#125;<br><br>    //.....省略其他没用的方法<br>&#125;<br></code></pre></td></tr></table></figure><p>通过Enum源码，可以知道，Enum实现了Comparable接口，这也是可以使用compareTo比较的原因，当然Enum构造函数也是存在的，该函数只能由编译器调用，我们只能使用enum关键字定义枚举.</p><h3 id="主要用法"><a href="#主要用法" class="headerlink" title="主要用法"></a>主要用法</h3><ul><li>1.常量</li><li>2.switch<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">switch (boxType.type) &#123;<br>            <span class="hljs-keyword">case</span> InlineNode:<br>                ...<br>                <span class="hljs-built_in">break</span>;<br>            <span class="hljs-keyword">case</span> AnonymousBlock:<br>                ...<br>                <span class="hljs-built_in">break</span>;<br>            <span class="hljs-keyword">case</span> BlockNode:<br>                ...<br>                <span class="hljs-built_in">break</span>;<br>            <span class="hljs-keyword">case</span> None:<br>                ...<br>                <span class="hljs-built_in">break</span>;<br>        &#125;<br></code></pre></td></tr></table></figure></li><li>3.向枚举中添加新方法<br>如果打算在enum类中定义方法，务必在声明完枚举实例后使用分号分开，倘若在枚举实例前定义任何方法，编译器都将会报错，无法编译通过，同时即使自定义了构造函数且enum的定义结束，<br>我们也永远无法手动调用构造函数创建枚举实例，毕竟这事只能由编译器执行。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">public enum Type &#123;<br>    //添加方法枚举时要用分号结束<br>    BlockNode(<span class="hljs-string">&quot;block&quot;</span>,1), InlineNode(<span class="hljs-string">&quot;inline&quot;</span>,2), AnonymousBlock(<span class="hljs-string">&quot;anonymous&quot;</span>,3), None(<span class="hljs-string">&quot;none&quot;</span>,4);<br>    <br>    //成员变量<br>    private final String <span class="hljs-built_in">type</span>;<br>    private final int i;<br>    <br>    //构造方法<br>    private Type(String <span class="hljs-built_in">type</span>,int i) &#123;<br>        this.type = <span class="hljs-built_in">type</span>;<br>        this.i = i;<br>    &#125;<br>    //定义方法<br>    public String <span class="hljs-function"><span class="hljs-title">getType</span></span>() &#123;<br>        <span class="hljs-built_in">return</span> <span class="hljs-built_in">type</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>4.覆盖枚举方法<br>父类Enum中的定义的方法只有toString方法没有使用final修饰，因此只能覆盖toString方法<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">public enum Type &#123;<br>    ...<br>    ...<br>    // 覆盖方法<br>    @Override<br>    public String <span class="hljs-function"><span class="hljs-title">toString</span></span>() &#123;<br>        <span class="hljs-built_in">return</span> this.index + <span class="hljs-string">&quot;_&quot;</span> + this.name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>5.实现接口<br>所有的枚举都继承自java.lang.Enum类。由于Java 不支持多继承，所以枚举对象不能再继承其他类。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">public interface interface_ &#123;<br>    void <span class="hljs-built_in">print</span>();<br><br>    String getInfo();<br>    &#125;<br><br>public enum Type implements interface_&#123;<br>    ...<br>    ...<br>    // 接口方法<br>    @Override<br>    public String <span class="hljs-function"><span class="hljs-title">getInfo</span></span>() &#123;<br>        <span class="hljs-built_in">return</span> this.name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>6.使用接口组织枚举 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">public interface Food &#123;<br>        enum Coffee implements Food &#123;<br>            BLACK_COFFEE, DECAF_COFFEE, LATTE, CAPPUCCINO<br>        &#125;<br><br>        enum Dessert implements Food &#123;<br>            FRUIT, CAKE, GELATO<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li>7.关于枚举集合的使用<br>java.util.EnumSet和java.util.EnumMap是两个枚举集合。EnumSet保证集合中的元素不重复;EnumMap中的 key是enum类型，而value则可以是任意类型。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://samsara98.gitee.io/samsara/&quot;&gt;SamsarA’s Blog&lt;/a&gt;! If you get any problems when reading my blog, you can&lt;br&gt;ask</summary>
      
    
    
    
    <category term="Study" scheme="https://wk1044481101.github.io/categories/Study/"/>
    
    
    <category term="-HTML" scheme="https://wk1044481101.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>CSS_JS</title>
    <link href="https://wk1044481101.github.io/2021/03/23/CSS_JS/"/>
    <id>https://wk1044481101.github.io/2021/03/23/CSS_JS/</id>
    <published>2021-03-23T08:27:53.000Z</published>
    <updated>2021-07-01T09:57:53.359Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://samsara98.gitee.io/samsara/">SamsarA’s Blog</a>! If you get any problems when reading my blog, you can<br>ask me on <a href="https://gitee.com/samsara98/samsara">Gitee</a>.</p><h1 id="CSS-JS"><a href="#CSS-JS" class="headerlink" title="CSS_JS"></a>CSS_JS</h1><pre><code>#HTML #CSS #Javascript #内网穿透</code></pre><p>&nbsp; You can get source code on my <a href="https://gitee.com/samsara98/adabank1">Gitee</a>.</p><h2 id="HTML、CSS、Javascript"><a href="#HTML、CSS、Javascript" class="headerlink" title="HTML、CSS、Javascript"></a>HTML、CSS、Javascript</h2><hr><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>HTML是Hyper Text Markup Language 超文本标记语言 的缩写， 用来表示网页展示的内容，由一套标记标签 （markup tag）组成，通常就叫标签。</p><ul><li>标签</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plain">1.段落<br>&lt;p&gt; 这是一个段落开始标签<br>&lt;&#x2F;p&gt; 这是一个这是一个段落开始标签结束标签<br>&lt;p&gt; Hello World &lt;&#x2F;p&gt; 标签之间的文本叫做内容<br>2.标题<br>&lt;h1&gt;大标题&lt;&#x2F;h1&gt;<br>&lt;h2&gt;小一点的标题&lt;&#x2F;h2&gt;<br>&lt;h3&gt;再小一点的标题&lt;&#x2F;h3&gt;<br>&lt;h4&gt;更小一点的标题&lt;&#x2F;h4&gt;<br>3.超链接<br>&lt;a&gt;标签即用来显示超链<br>&lt;a href&#x3D;&quot;跳转到的页面地址&quot;&gt;超链显示文本&lt;&#x2F;a&gt;<br>4.块标签<br>&lt;div&gt;&lt;span&gt;<br>这两种标签都是布局用的,这种标签本身没有任何显示效果<br>通常是用来结合css进行页面布局<br>4.图像<br>&lt;img&gt; 即图像标签，需要设置其属性 src指定图像的路径，<br>&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;how2j.cn&#x2F;example.gif&quot;&#x2F;&gt;<br>...<br>...<br></code></pre></td></tr></table></figure><ul><li>属性<br>用来修饰标签的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">1.比如要设置一个标题居中<br>&lt;h1 align&#x3D;&quot;center&quot;&gt;居中标题&lt;&#x2F;h1&gt;<br>2.在新的页面打开超链 <br>&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.12306.cn&quot; target&#x3D;&quot;_blank&quot;&gt;http:&#x2F;&#x2F;www.12306.cn&lt;&#x2F;a&gt;<br>3.当鼠标放在超链上的时候，就会弹出提示文字 <br>&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.12306.com&quot; title&#x3D;&quot;跳转到http:&#x2F;&#x2F;www.12306.com&quot;&gt;www.12306.com&lt;&#x2F;a&gt;<br></code></pre></td></tr></table></figure><ul><li>注释</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">html使用&lt;!-- --&gt; 进行注释 <br></code></pre></td></tr></table></figure><hr><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>CSS 是一种描述 HTML 文档样式的语言，描述应该如何显示 HTML 元素。<br>样式文件保存为.css文件，通过html页面的head中的link标签引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;head&gt;<br>    ...<br>    ...<br>    &lt;link rel=<span class="hljs-string">&quot;stylesheet&quot;</span> type=<span class="hljs-string">&quot;text/css&quot;</span> href=<span class="hljs-string">&quot;index.css&quot;</span> media=<span class="hljs-string">&quot;all&quot;</span>&gt;<br>        ...<br>&lt;/head&gt;<br></code></pre></td></tr></table></figure><p>css可以描述html页面展示部分样式，使用选择器来描述具体需要实现的部分</p><ul><li>元素选择器</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//描绘html-body部分</span><br>body<br>&#123;<br>    background:#f9f9f9;<br>    color:#333;<br>    font - size<br>:<br>    <span class="hljs-number">12</span><br>    px;<br>    font - family<br>:<br>    <span class="hljs-string">&quot;微软雅黑&quot;</span>, <span class="hljs-string">&quot;Microsoft YaHei&quot;</span>, Arial, sans - serif<br>&#125;<br><span class="hljs-comment">//描述段落标签</span><br>p<br>&#123;<br>    margin:<span class="hljs-number">0</span>;<br>    margin - bottom<br>:<br>    <span class="hljs-number">10</span><br>    px;<br>    clear:both<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>类选择器</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">.<br>input<br>&#123;<br>    width:<span class="hljs-number">192</span><br>    px;<br>    padding:<span class="hljs-number">2</span><br>    px<br>    <span class="hljs-number">3</span><br>    px;<br>    height:<span class="hljs-number">16</span><br>    px;<br>    border:<span class="hljs-number">1</span><br>    px<br>    solid<br>    #ccc<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>ID选择器</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">#AB<br>&#123;<br>    font - size<br>:<br>    <span class="hljs-number">12</span><br>    px<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>描绘标签的行为</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//当超链接被鼠标指向时的画面描述</span><br>a:active, a<br>:<br>hover<br>&#123;<br>    outline:<span class="hljs-number">0</span><br>    none<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h3><p>JavaJavaScript 是一种脚本，一门编程语言，它可以在网页上实现复杂的功能， 网页展现给你的不再是简单的静态信息，而是实时的内容更新， 交互式的地图，2D/3D 动画，滚动播放的视频等等。</p><p>客户端（client-side）JavaScript 语言的核心包含一些普遍的编程特性，以让你可以做到如下的事情：</p><ul><li>在变量中储存有用的值。比如上文的示例中，我们请求客户输入一个新名字，然后将其储存到 name 变量中。</li><li>操作一段文本（在编程中称为“字符串”（string））。上文的示例中，我们取字符串 “玩家1：”，然后把它和 name 变量连结起来，创造出完整的文本标签，比如：“玩家1：小明”。</li><li>运行代码以响应网页中发生的特定事件。上文的示例中，我们用一个 click 事件来检测按钮什么时候被点击，然后运行代码更新文本标签。</li></ul><p>JavaScript分为内部和外部：</p><ul><li>内部写在html内部</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;script&gt;<br>      &#x2F;&#x2F; 在此编写 JavaScript 代码<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><ul><li>外部写为.js文件，通过html内部添加</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script src=<span class="hljs-string">&quot;script.js&quot;</span> <span class="hljs-keyword">async</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><h2 id="IP地址、内网穿透"><a href="#IP地址、内网穿透" class="headerlink" title="IP地址、内网穿透"></a>IP地址、内网穿透</h2><p>在Internet没有形成之前，各个地方已经建立了很多小型的网络， 称为局域网。Internet的中文意义是“互联网”， 它实际上就是将全球各地的局域网连接起来而形成的一个可以互相连接的网络（即互联网）</p><p>在互联网中IP地址相当于我们的门牌号，分为内网和外网IP</p><ul><li>公网IP是在全球内是唯一的，作为身份的标识 ，可以通过公网地址能直接访问因特网。</li><li>内网IP则属于非注册地址，只在局域网内有效，在公网上是不能使用内网IP地址来实现互联网访问的。</li></ul><p>现在的关键问题是地址的长度不够，IPv4长度有限，不能囊括全球每个人一个IP的需求， 靠NAT技术来沟通内外网。 未来使用IPv6就能解决这个问题。 而内网穿透服务则是利用一个有公网IP的服务器代为传递信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://samsara98.gitee.io/samsara/&quot;&gt;SamsarA’s Blog&lt;/a&gt;! If you get any problems when reading my blog, you can&lt;br&gt;ask</summary>
      
    
    
    
    <category term="Study" scheme="https://wk1044481101.github.io/categories/Study/"/>
    
    
    <category term="-HTML" scheme="https://wk1044481101.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>IP_TCP_HTTP</title>
    <link href="https://wk1044481101.github.io/2021/03/19/IP_TCP_HTTP/"/>
    <id>https://wk1044481101.github.io/2021/03/19/IP_TCP_HTTP/</id>
    <published>2021-03-19T06:08:53.000Z</published>
    <updated>2021-07-01T09:52:28.027Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://samsara98.gitee.io/samsara/">SamsarA’s Blog</a>! If you get any problems when reading my blog, you can<br>ask me on <a href="https://gitee.com/samsara98/samsara">Gitee</a>.</p><h1 id="wechat"><a href="#wechat" class="headerlink" title="wechat"></a>wechat</h1><pre><code>#HTTP协议  #Broswer/Client模式  #HTML  #servlet</code></pre><p>&nbsp; You can get source code on my <a href="https://gitee.com/samsara98/wechat">Gitee</a>.</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>在Web应用中，浏览器请求一个URL，服务器就把生成的HTML网页发送给浏览器，而浏览器和服务器之间的传输协议是HTTP</p><ul><li>IP–&gt; TCP –&gt; HTTP<br>HTTP协议建立在TCP协议之上，需要建立连接。TCP协议建立在IP协议之上，使得在不稳定的IP协议上建立稳定的连接。</li></ul><p>对于Browser来说，请求页面的流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">1.与服务器建立TCP连接；<br>2.发送HTTP请求；<br>3.收取HTTP响应，然后把网页在浏览器中显示出来。<br></code></pre></td></tr></table></figure><h3 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h3><ul><li>三次握手<br><img src="https://img2018.cnblogs.com/blog/1845293/201912/1845293-20191213172857264-1062160369.png" alt="1.png"><h3 id="TCP连接释放"><a href="#TCP连接释放" class="headerlink" title="TCP连接释放"></a>TCP连接释放</h3></li><li>四次挥手<br><img src="https://img2018.cnblogs.com/blog/1845293/201912/1845293-20191213234439862-587275161.png" alt="2.png"><h3 id="浏览器发送的HTTP请求如下："><a href="#浏览器发送的HTTP请求如下：" class="headerlink" title="浏览器发送的HTTP请求如下："></a>浏览器发送的HTTP请求如下：</h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">GET &#x2F; HTTP&#x2F;1.1<br>Host: www.sina.com.cn<br>User-Agent: Mozilla&#x2F;5.0 xxx<br>Accept: *&#x2F;*<br>Accept-Language: zh-CN,zh;q&#x3D;0.9,en-US;q&#x3D;0.8<br></code></pre></td></tr></table></figure><p>其中，第一行表示使用GET请求获取路径为/的资源，并使用HTTP/1.1协议，从第二行开始，每行都是以Header: Value形式表示的HTTP头，比较常用的HTTP Header包括：</p><ul><li>Host: 表示请求的主机名，因为一个服务器上可能运行着多个网站，因此，Host表示浏览器正在请求的域名；</li><li>User-Agent: 标识客户端本身，例如Chrome浏览器的标识类似Mozilla/5.0 … Chrome/79，IE浏览器的标识类似Mozilla/5.0 (Windows NT …) like Gecko；</li><li>Accept：表示浏览器能接收的资源类型，如text/*，image/<em>或者</em>/*表示所有；</li><li>Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；</li><li>Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate, br。</li></ul><h3 id="服务器的响应如下："><a href="#服务器的响应如下：" class="headerlink" title="服务器的响应如下："></a>服务器的响应如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">HTTP&#x2F;1.1 200 OK<br>Content-Type: text&#x2F;html<br>Content-Length: 21932<br>Content-Encoding: gzip<br>Cache-Control: max-age&#x3D;300<br>&lt;html&gt;...网页数据...<br></code></pre></td></tr></table></figure><p>服务器响应的第一行总是版本号+空格+数字+空格+文本，数字表示响应代码， 其中2xx表示成功，3xx表示重定向，4xx表示客户端引发的错误，5xx表示服务器端引发的错误。 数字是给程序识别，文本则是给开发者调试使用的。常见的响应代码有：</p><ul><li>200 OK：表示成功；</li><li>301 Moved Permanently：表示该URL已经永久重定向；</li><li>302 Found：表示该URL需要临时重定向；</li><li>304 Not Modified：表示该资源没有修改，客户端可以使用本地缓存的版本；</li><li>400 Bad Request：表示客户端发送了一个错误的请求，例如参数无效；</li><li>401 Unauthorized：表示客户端因为身份未验证而不允许访问该URL；</li><li>403 Forbidden：表示服务器因为权限问题拒绝了客户端的请求；</li><li>404 Not Found：表示客户端请求了一个不存在的资源；</li><li>500 Internal Server Error：表示服务器处理时内部出错，例如因为无法连接数据库；</li><li>503 Service Unavailable：表示服务器此刻暂时无法处理请求。</li></ul><p>从第二行开始，服务器每一行均返回一个HTTP头。服务器经常返回的HTTP Header包括：</p><ul><li>Content-Type：表示该响应内容的类型，例如text/html，image/jpeg；</li><li>Content-Length：表示该响应内容的长度（字节数）；</li><li>Content-Encoding：表示该响应压缩算法，例如gzip；</li><li>Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒。</li></ul><p>HTTP请求和响应都由HTTP Header和HTTP Body构成，其中HTTP Header每行都以\r\n结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;head&gt;<br>...<br>Content-Type : ...<br>Content-Encoding : ...<br>&lt;&#x2F;head&gt;<br>&lt;body&gt;<br>...<br>&lt;&#x2F;body&gt;<br></code></pre></td></tr></table></figure><p>如果遇到两个连续的\r\n，那么后面就是HTTP Body。浏览器读取HTTP Body,<br>并根据Header信息中指示的Content-Type、Content-Encoding等解压后显示网页、图像或其他内容。<br>通常浏览器获取的第一个资源是HTML网页，在网页中，如果嵌入了JavaScript、CSS、图片、视频等其他资源，浏览器会根据资源的URL再次向服务器请求对应的资源。</p><h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</p><p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。</p><p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p><p>并不是每个服务器都实现了所有的方法，如果要跟HTTP1.1兼容，那么只要为其资源实现GET方法和HEAD方法就可以了。</p><p>即使服务器实现了所有这些方法，这些方法的使用很可能也是受限的，这些限制通常都是在服务器的配置中进行设置的，因此会随着站点和服务器的不同而有所不同。</p><ul><li>GET   </li></ul><p>GET是最常用的方法，通常用于请求服务器发送某个资源。HTTP/1.1 要求服务器实现该方法。</p><ul><li>POST<br>POST方法期初是用来向服务器输入数据的，实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到它要去的地方。</li></ul><p>GET和POST的区别：<br>1、GET请求的数据是放在HTTP包头中的，也就是URL之后，通常是像下面这样定义格式的：<br>login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%E5%A5%BD<br>其中，以?来分隔URL和数据；以&amp;来分隔参数；如果数据是英文或数字，原样发送；如果数据是中文或其它字符，则进行BASE64编码。<br>而Post是把提交的数据放在HTTP正文中的。   </p><p>2、GET提交的数据比较少，最多1024B，因为GET数据是附在URL之后的，而URL则会受到不同环境的限制的，比如说IE对其限制为2K+35，而POST可以传送更多的数据（理论上是没有限制的，但一般也会受不同的环境，如浏览器、操作系统、服务器处理能力等限制，IIS4可支持80KB，IIS5可支持100KB）。</p><p>3、Post的安全性要比Get高，因为Get时，参数数据是明文传输的，参数直接暴露在url中，所以不能用来传递敏感信息。而且使用GET的话，还可能造成Cross-site request forgery攻击。而POST数据则可以加密的，但GET的速度可能会快些。</p><p>4、get请求只能进行url编码，而post支持多种编码方式；get请求会浏览器主动cache，而post支持多种编码方式；get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。</p><p>5、GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p><p>6、GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://samsara98.gitee.io/samsara/&quot;&gt;SamsarA’s Blog&lt;/a&gt;! If you get any problems when reading my blog, you can&lt;br&gt;ask</summary>
      
    
    
    
    <category term="Study" scheme="https://wk1044481101.github.io/categories/Study/"/>
    
    
    <category term="-HTTP" scheme="https://wk1044481101.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>注解_反射_测试</title>
    <link href="https://wk1044481101.github.io/2021/03/02/%E6%B3%A8%E8%A7%A3_%E5%8F%8D%E5%B0%84_%E6%B5%8B%E8%AF%95/"/>
    <id>https://wk1044481101.github.io/2021/03/02/%E6%B3%A8%E8%A7%A3_%E5%8F%8D%E5%B0%84_%E6%B5%8B%E8%AF%95/</id>
    <published>2021-03-02T09:00:14.000Z</published>
    <updated>2021-07-01T09:54:13.295Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://samsara98.gitee.io/samsara/">SamsarA’s Blog</a>! If you get any problems when reading my blog, you can<br>ask me on <a href="https://gitee.com/samsara98/samsara">Gitee</a>.</p><h1 id="Tetris"><a href="#Tetris" class="headerlink" title="Tetris"></a>Tetris</h1><pre><code>#面向测试编程 #继承 #多态 #人工智能 #注解 # 反射</code></pre><p>&nbsp; You can get source code on my <a href="https://gitee.com/samsara98/tetris">Gitee</a>.</p><h2 id="面向测试编程"><a href="#面向测试编程" class="headerlink" title="面向测试编程"></a>面向测试编程</h2><p>先完成测试代码，以通过测试代码为目标后完成编程，采用Junit，Junit通过注解工作。</p><ul><li>@Rule</li></ul><p>类似于拦截器，用于在测试方法执行前后添加额外的处理。实际上是@Before，@After的另一种实现。 使用时需要修饰符为public。Rule会应用于该类每个测试方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">@Rule<br>    public Timeout timeout = Timeout.millis(100);//为全部测试程序设置时限   <br></code></pre></td></tr></table></figure><ul><li>@Before</li></ul><p>当编写测试方法时，经常会发现一些方法在执行前需要创建相同的对象 使用@Before注解一个public void 方法会使该方法在@Test注解方法被执行前执行（那么就可以在该方法中创建相同的对象）<br>父类的@Before注解方法会在子类的@Before注解方法执行前执行</p><ul><li>@Test</li></ul><p>@Test注解的public void方法将会被当做测试用例，JUnit每次都会创建一个新的测试实例，然后调用@Test注解方法</p><p>任何异常的抛出都会认为测试失败</p><p>@Test注解提供2个参数：</p><p>1，“expected”，定义测试方法应该抛出的异常，如果测试方法没有抛出异常或者抛出了一个不同的异常，测试失败</p><p>2，“timeout”，如果测试运行时间长于该定义时间，测试失败（单位为毫秒）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">@Test<br>public void <span class="hljs-function"><span class="hljs-title">gamingAreaTest</span></span>() &#123;<br>    //常用的四种assert<br>    assertEquals(5, gamingArea.getAreaWidth());<br>    assertNotEquals(5, gamingArea.getAreaWidth());<br>    assertFalse(gamingArea.isFilled(1, 1));<br>    assertTrue(gamingArea.isFilled(0, 1));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>@Ignore</li></ul><p>有时候我们想暂时不运行某些测试方法\测试类，可以在方法前加上这个注解。在运行结果中， junit会统计忽略的用例数，来提醒你。但是不建议经常这么做，因为这样的坏处时，容易忘记去更新这些测试方法，导致代码不够干净，用例遗漏。</p><ul><li>@BeforeClass</li></ul><p>当我们运行几个有关联的用例时，可能会在数据准备或其它前期准备中执行一些相同的命令，<br>这个时候为了让代码更清晰，更少冗余，可以将公用的部分提取出来，放在一个方法里，并为这个方法注解@BeforeClass。意思是在测试类里所有用例运行之前，运行一次这个方法。例如创建数据库连接、读取文件等。</p><ul><li>@AfterClass</li></ul><p>跟@BeforeClass对应，在测试类里所有用例运行之后，运行一次。用于处理一些测试后续工作，例如清理数据，恢复现场。</p><p>注意：同样必须是public static void，即公开、静态、无返回。这个方法只会运行一次。</p><hr><h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><p>子类继承父类，可以访问protected修饰的方法和字段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class AITetris extends Tetris implements AI &#123;<br>  ...<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>对于父类存在的方法需要修改，可以使用@Override注解，修饰器会提示是否正确重写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">重写override：方法签名与父类相同，即返回值，方法名，参数类型      <br>重载overload：方法的名字相同，返回值一般不变，但是改变方法的参数类型和参数数量。<br></code></pre></td></tr></table></figure><p>在重写的方法中需要调用父类方法使用super.方法名（）来调用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">@Override<br>public void tick(int direction) &#123;<br>    ...<br>    super.tick(direction);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p><ul><li>@Target</li></ul><p>最常用的元注解是@Target。使用@Target可以定义Annotation能够被应用于源码的哪些位置：</p><p>  类或接口：ElementType.TYPE；<br>  字段：ElementType.FIELD；<br>  方法：ElementType.METHOD；<br>  构造方法：ElementType.CONSTRUCTOR；<br>  方法参数：ElementType.PARAMETER。</p><p>定义注解@Report可用在方法或字段上，可以把@Target注解参数变为数组{ ElementType.METHOD, ElementType.FIELD }：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">@Target(&#123;<br>ElementType.METHOD,<br>ElementType.FIELD<br>&#125;)<br>public @interface Report &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上@Target定义的value是ElementType[]数组，只有一个元素时，可以省略数组的写法。</p><ul><li>@Retention</li></ul><p>另一个重要的元注解@Retention定义了Annotation的生命周期：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">仅编译期：RetentionPolicy.SOURCE；<br>仅class文件：RetentionPolicy.CLASS；<br>运行期：RetentionPolicy.RUNTIME。<br></code></pre></td></tr></table></figure><p>如果@Retention不存在，则该Annotation默认为CLASS。因为通常我们自定义的Annotation都是RUNTIME，所以，务必要加上@Retention(RetentionPolicy.RUNTIME)这个元注解：</p><ul><li>@Repeatable</li></ul><p>使用@Repeatable这个元注解可以定义Annotation是否可重复。这个注解应用不是特别广泛。</p><ul><li>@Inherited</li></ul><p>使用@Inherited定义子类是否可继承父类定义的Annotation。@Inherited仅针对@Target(ElementType.TYPE)<br>类型的annotation有效，并且仅针对class的继承，对interface的继承无效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">@Inherited<br>@Target(ElementType.TYPE)<br>public @interface Report &#123;<br>int <span class="hljs-built_in">type</span>() default 0;<br>String level() default <span class="hljs-string">&quot;info&quot;</span>;<br>String value() default <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在使用的时候，如果一个类用到了@Report：</p><p>@Report(type=1)<br>public class Person { }</p><p>则它的子类默认也定义了该注解：</p><p>public class Student extends Person { }</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。 Java的注解可以分为三类，通过元注解@Retention来标注:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">仅编译期：RetentionPolicy.SOURCE； <br>仅class文件：RetentionPolicy.CLASS；<br>运行期：RetentionPolicy.RUNTIME<br></code></pre></td></tr></table></figure><ul><li>第一类是由编译器使用的注解（）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">@Override：让编译器检查该方法是否正确地实现了覆写；   <br>@SuppressWarnings：告诉编译器忽略此处代码产生的警告。<br></code></pre></td></tr></table></figure><p>这类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了。</p><ul><li>第二类是由工具处理.class文件使用的注解   </li></ul><p>比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入.class文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</p><ul><li>第三类是在程序运行期能够读取的注解   </li></ul><p>它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了@PostConstruct的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p><p>定义一个注解时，还可以定义配置参数。配置参数可以包括：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">所有基本类型；<br>String；<br>枚举类型；<br>基本类型、String、Class以及枚举的数组。<br></code></pre></td></tr></table></figure><p>因为配置参数必须是常量，所以，上述限制保证了注解在定义时就已经确定了每个参数的值。</p><p>注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。</p><p>此外，大部分注解会有一个名为value的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。</p><p>如果只写注解，相当于全部使用默认值。</p><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>第一步，用@interface定义注解：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">public @interface Report &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二步，添加参数、默认值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">public @interface Report &#123;<br>int <span class="hljs-built_in">type</span>() default 0;<br>String level() default <span class="hljs-string">&quot;info&quot;</span>;<br>String value() default <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>把最常用的参数定义为value()，推荐所有参数都尽量设置默认值。</p><p>第三步，用元注解配置注解：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">@Target(ElementType.TYPE)<br>@Retention(RetentionPolicy.RUNTIME)<br>public @interface Report &#123;<br>int <span class="hljs-built_in">type</span>() default 0;<br>String level() default <span class="hljs-string">&quot;info&quot;</span>;<br>String value() default <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，必须设置@Target和@Retention，@Retention一般设置为RUNTIME，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写@Inherited和@Repeatable。</p><p>第四步，使用反射获取注解信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">@Aconfig(ip = <span class="hljs-string">&quot;123&quot;</span>)<br>public class Test1 &#123;<br>  ...<br>  &#125;<br>  <br>Test1 ab = new Test1();<br>Aconfig aconfigs = ab.getClass().getAnnotation(Aconfig.class);<br>String ip = aconfigs.ip();<br></code></pre></td></tr></table></figure><hr><h2 id="EL-Tetris"><a href="#EL-Tetris" class="headerlink" title="EL-Tetris"></a>EL-Tetris</h2><p>使用算法自动游玩Tetris，算法类似专家模式，特征值权重数值由已经训练完成的AI得到。</p><ul><li><p>EL-Tetris算法主要分析6个特征点</p><p>第一个特征点是 Landing Height。表示当前方块放置之后的高度。这个高度的计算方法是使用当前容器内方块的高度加上当前下落方块的一半。<br>第二个特征点是 Rows eliminated。表示当前方块落下后被消减的行数。<br>第三个特征点是 Row Transitions。代表容器中水平方向上变换的次数。<br>第四个特征点是 Column Transitions。和第三个特征点类似，只不过这一次算的是列变换而已。<br>第五个特征点是 Number of Holes。代表图中空洞的个数。<br>第六个特征点是 Well Sums。表示 “井” 深的连加和。一个 “井” 代表左右都有，而中间为空洞的形状。</p></li><li><p>算法权重<br>Landing Height ———-&gt;&gt;&gt;&gt;    -4.500158825082766<br>Rows eliminated ——–&gt;&gt;&gt;&gt;   3.4181268101392694<br>Row Transitions ——–&gt;&gt;&gt;&gt;   -3.2178882868487753<br>Column Transitions ——&gt;&gt;&gt;&gt;-9.348695305445199<br>Number of Holes ——–&gt;&gt;&gt;&gt;   -7.899265427351652<br>Well Sums —————&gt;&gt;&gt;&gt;  -3.3855972247263626</p></li></ul><p>遍历所有可能的方块放置点位，根据特征值和权重计算分数，分数最高即为最佳放置点位。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs bash">/**<br> * 根据shape和area计算最佳选择<br> *<br> * @param gamingArea 游戏区域<br> * @param shape      当前掉落的方块<br> * @<span class="hljs-built_in">return</span> 包含最佳的shape，x，y<br> */<br>default Move Axis(GamingArea gamingArea, Shape shape) &#123;<br>    ...<br>    ...<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">for</span> (int col = 0; col &lt; gamingArea.getAreaWidth(); col++) &#123;<br>                ...<br>                ...<br>                //EL-Tetris 6大指标<br>                //shape放下后重心高度<br>                int LandingHeight = row + (shape.getHeight() + 1) / 2;<br>                //可消除行数*shape贡献的方块数<br>                int RowsEliminated = gamingArea.clearRows() * gamingArea.getChangeNum();<br>                //横向变化程度<br>                int RowTransition = RowTransition(gamingArea);<br>                //纵向变化程度<br>                int ColumnTransitions = ColumnTransitions(gamingArea);<br>                //空洞数<br>                int NumberOfHoles = NumberOfHoles(gamingArea);<br>                //井深累加和<br>                int WellSums = WellSums(gamingArea);<br>                //方块高度最大差值<br>                int range = gamingArea.range();<br><br>                //评估函数<br>                double score = (-45 * LandingHeight) +<br>                        (34 * RowsEliminated) +<br>                        (-32 * RowTransition) +<br>                        (-94 * ColumnTransitions) +<br>                        (-79 * NumberOfHoles) +<br>                        (-34 * WellSums);<br>                //取最大分数<br>                <span class="hljs-keyword">if</span> (score &gt;= bestScore) &#123;<br>                    bestCol = col;<br>                    bestRow = row;<br>                    bestScore = score;<br>                    best = shape;<br>                &#125;<br>            &#125;<br>            gamingArea.undo();<br>        &#125;<br>        //将该方块所以旋转角度都遍历一次<br>        <span class="hljs-keyword">if</span> (shape.fastRotation().equals(root)) &#123;<br>            <span class="hljs-built_in">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            shape = shape.fastRotation();<br>        &#125;<br>    &#125;<br><br>    // 返回计算出的bestMove<br>    Move bestMove = new Move();<br>    bestMove.shape = best;<br>    bestMove.x = bestCol;<br>    bestMove.y = bestRow;<br>    bestMove.score = bestScore;<br>    <span class="hljs-built_in">return</span> bestMove;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://samsara98.gitee.io/samsara/&quot;&gt;SamsarA’s Blog&lt;/a&gt;! If you get any problems when reading my blog, you can&lt;br&gt;ask</summary>
      
    
    
    
    <category term="Study" scheme="https://wk1044481101.github.io/categories/Study/"/>
    
    
    <category term="-Java" scheme="https://wk1044481101.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>泛型_函数式编程</title>
    <link href="https://wk1044481101.github.io/2021/02/05/%E6%B3%9B%E5%9E%8B_%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://wk1044481101.github.io/2021/02/05/%E6%B3%9B%E5%9E%8B_%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2021-02-05T09:09:05.000Z</published>
    <updated>2021-07-01T09:51:24.928Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://samsara98.gitee.io/samsara/">SamsarA’s Blog</a>! If you get any problems when reading my blog, you can<br>ask me on <a href="https://gitee.com/samsara98/samsara">Gitee</a>.</p><h2 id="泛型-函数式编程"><a href="#泛型-函数式编程" class="headerlink" title="泛型_函数式编程"></a>泛型_函数式编程</h2><pre><code>#泛型  #函数式编程  #Stream  #Hash  </code></pre><p>&nbsp; You can get source code on my <a href="https://gitee.com/samsara98/younameit">Gitee</a>.</p><hr><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。<br>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p>泛型方法：</p><ul><li>所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的<E>）。</li><li>每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。</li><li>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。</li><li>泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等）。</li></ul><p>泛型类：</p><ul><li>和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。 和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。</li><li>一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。 因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。</li></ul><p>泛型集合：</p><ul><li>B extends A; 可放入A以及A的子类对象,例如B类的对象</li><li>基本对象放入必须是其包装类：Integer、Double…</li><li>A与B有继承关系，ArrayList<A/>和ArrayList<B>则没有继承</li></ul><h3 id="泛型集合-类-方法"><a href="#泛型集合-类-方法" class="headerlink" title="泛型集合/类/方法"></a>泛型集合/类/方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">ArrayList&lt;A&gt; heros = new ArrayList&lt;A&gt;();<br>// 后面的泛型类型可以省略<br>ArrayList&lt;A&gt; heros = new ArrayList&lt;&gt;();<br>// A与B有继承关系，ArrayList&lt;A&gt;和ArrayList&lt;B&gt;则没有继承关系<br>// 错误<br>ArrayList&lt;A&gt; lista = new ArrayList&lt;B&gt;;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 设计这个类的时候，在类的声明上，加上一个&lt;T&gt;，表示该类支持泛型。<br>&#x2F;&#x2F; T是type的缩写，也可以使用任何其他的合法的变量，比如A,B,X都可以，但是一般约定成俗使用T，代表类型。<br>public class MyStack&lt;T&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。<br>&#x2F;&#x2F; 前面的&lt;T&gt;代表这是个泛型方法，返回的类型List&lt;T&gt;<br>public &lt;T&gt; List&lt;T&gt; foo(List&lt;T&gt; list)&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">？ extends泛型通配符：<br>ArrayList heroList&lt;? extends Hero&gt; 表示这是一个Hero泛型或者其子类泛型   <br>heroList 的泛型可能是Hero   <br>heroList 的泛型可能是APHero   <br>heroList 的泛型可能是ADHero  <br>所以 可以确凿的是，从heroList取出来的对象，一定是可以转型成Hero的，但是，不能往里面放东西<br></code></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">？ super泛型通配符：<br>ArrayList heroList&lt;? super Hero&gt; 表示这是一个Hero泛型或者其父类泛型<br>heroList的泛型可能是Hero<br>heroList的泛型可能是Object<br>可以往里面插入Hero以及Hero的子类<br>但是取出来有风险，因为不确定取出来是Hero还是Object <br></code></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">？泛型通配符：<br>表示任意泛型，所以只能以Object的形式取出来并且不能往里面放对象，因为不知道到底是一个什么泛型的容器 <br>ArrayList&lt;?&gt; generalList &#x3D; apHeroList;<br></code></pre></td></tr></table></figure><h3 id="类型擦拭"><a href="#类型擦拭" class="headerlink" title="类型擦拭"></a>类型擦拭</h3><p>Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉， 正确理解泛型概念的首要前提是理解类型擦除。Java的泛型基本上都是在编译器这个层次上实现的，<br>在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉， 这个过程成为类型擦除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 在JVM中<br>ArrayList&lt;String&gt; <br>相当于<br>ArrayList;<br>&#x2F;&#x2F; 编译器会限制我们只能向ArrayList&lt;String&gt;插入String对象，防止出错，但在JVM中是允许ArrayList&lt;String&gt;插入任意对象的。<br><br>public &lt;T&gt; void foo(&lt;T&gt; t)&#123;<br>&#125;<br>相当于<br>public void foo(Object t)&#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">public class MyStack&lt;T&gt; &#123;<br>    public MyStack(&lt;T&gt; t)&#123;<br>        &#x2F;&#x2F; 创建对象，可以通过编译<br>        T t &#x3D; t.getInstance();<br>        &#x2F;&#x2F;JVM中T无法得知，无法创建实例，无法编译<br>        Object object &#x3D; new T();<br>        &#x2F;&#x2F;可以通过编译<br>        Object object &#x3D; (T) new Object();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">public String foo(ArrayList&lt;String&gt; list)&#123;<br>&#125;<br>public String foo(ArrayList&lt;int&gt; list)&#123;<br>&#125;<br>&#x2F;&#x2F;这两个重载方法在JVM中是完全一样的，无法重载，方法名重复错误<br></code></pre></td></tr></table></figure><hr><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>实现Functional接口，主要有三种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">@Documented<br>@Retention(RetentionPolicy.RUNTIME)<br>@Target(ElementType.TYPE)<br>public @interface FunctionalInterface &#123;&#125;<br></code></pre></td></tr></table></figure><ul><li>有且仅有一个抽象方法</li><li>加上标注,则会触发JavaCompiler的检查。提供一层编译检查的保障。如果不符合，则会报错。</li><li>不能被覆盖之后，再声明为抽象方法，则不算抽象方法。例如接口实现了Object中的方法。</li><li>可用于lambda类型的使用方式</li></ul><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>Function是从T到R的一元映射函数。将参数T传递给一个函数，返回R。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs plain">@FunctionalInterface<br>public interface Function&lt;T, R&gt; &#123;<br>  &#x2F;**<br>  * Function&lt;Integer, Integer&gt; f &#x3D; s -&gt; s++; 有输入和输出<br>  * Function&lt;Integer, Integer&gt; g &#x3D; s -&gt; s*2;<br>  *&#x2F;<br>  R apply(T t);<br>  <br>  &#x2F;**<br>  * 表示在执行时，先执行before，然后使用before的输出当作当前函数输入。<br>  * f.compose(g).apply(1)<br>  *&#x2F;<br>  default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123;<br>         Objects.requireNonNull(before);<br>         return (V v) -&gt; apply(before.apply(v));<br>  &#125;<br>  <br>  &#x2F;**<br>  * 表示在执行时，先执行当前函数，并且执行after时使用当前函数的输出当作输入。<br>  * f.andThen(g).apply(1)<br>  *&#x2F;<br>  default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123;<br>        Objects.requireNonNull(after);<br>        return (T t) -&gt; after.apply(apply(t));<br>  &#125;<br>  <br>  &#x2F;**<br>  * identity方法会返回一个不进行任何处理的Function，即输出与输入值相等；<br>  * f.andThen(g).apply(1)<br>  * Function.identity().apply(&quot;a&quot;)<br>  *&#x2F; <br>  static &lt;T&gt; Function&lt;T, T&gt; identity() &#123;<br>         return t -&gt; t;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p>Predicate，判断的意思，判断某个东西是否满足某种条件； 因此它包含test方法，根据输入值来做逻辑判断，其结果为True或者False。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs plain">@FunctionalInterface<br>public interface Predicate&lt;T&gt; &#123;<br>    &#x2F;**<br>    * Predicate&lt;String&gt; p &#x3D; o -&gt; o.equals(&quot;test&quot;); 输出判断结果<br>    *&#x2F;<br>    boolean test(T t);<br>    <br>    &#x2F;**<br>    * and: 针对同一输入值，多个Predicate均返回True时返回True，否则返回False；<br>    * p.and(g).test(&quot;test&quot;)<br>    *&#x2F; <br>    default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123;<br>          Objects.requireNonNull(other);<br>          return (t) -&gt; test(t) &amp;&amp; other.test(t);<br>    &#125;<br>      <br>    &#x2F;**<br>    * 用于对原来的Predicate做取反处理；<br>    * 调用p.test(&quot;test&quot;)为True时，调用p.negate().test(&quot;test&quot;)就会是False；<br>    *&#x2F;       <br>     default Predicate&lt;T&gt; negate() &#123;<br>         return (t) -&gt; !test(t);<br>    &#125;<br>    <br>    &#x2F;**<br>    * or: 针对同一输入值，多个Predicate只要有一个返回True则返回True，否则返回False<br>    * p.or(g).test(&quot;test&quot;)；<br>    *&#x2F; <br>    default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) &#123;<br>         Objects.requireNonNull(other);<br>         return (t) -&gt; test(t) || other.test(t);<br>    &#125;<br>    <br>    &#x2F;**<br>    * isEqual方法接收一个Object对象,返回一个Predicate类型.此Predicate用于判断输入的对象是否与object对象相等(equals)<br>    * Predicate.isEqual(&quot;test&quot;).test(&quot;test&quot;);<br>    *&#x2F; <br>    static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) &#123;<br>         return (null &#x3D;&#x3D; targetRef)<br>                 ? Objects::isNull<br>                 : object -&gt; targetRef.equals(object);<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>Consumer是从T到void的函数，可以接受参数，但不返回任何结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plain">@FunctionalInterface<br>public interface Consumer&lt;T&gt; &#123;<br>    &#x2F;**<br>    * Consumer f &#x3D; System.out::println;  (类名&#x2F;对象名)::(静态方法&#x2F;方法)<br>    * Consumer f2 &#x3D; n -&gt; System.out.println(n + &quot;-F2&quot;);<br>    *&#x2F;<br>    void accept(T t);<br>    <br>    &#x2F;** <br>    * andThen指定在调用当前Consumer后是否还要调用其它的Consumer； <br>    * f.andThen(f).andThen(f).andThen(f).accept(&quot;test1&quot;);<br>    *&#x2F;<br>    default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123;<br>     Objects.requireNonNull(after);<br>     return (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p>Lambda 的基本结构为 (arguments) -&gt; body，有如下几种情况：</p><ul><li>参数类型可推导时，不需要指定类型，如 (a) -&gt; System.out.println(a)</li><li>当只有一个参数且类型可推导时，不强制写 (), 如 a -&gt; System.out.println(a)</li><li>参数指定类型时，必须有括号，如 (int a) -&gt; System.out.println(a)</li><li>参数可以为空，如 () -&gt; System.out.println(“hello”)</li><li>body 需要用 {} 包含语句，当只有一条语句时 {} 可省略<br>例如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">(x) -&gt; x&gt;1; (Precidate)   <br>(x) -&gt; System.out::println; (Consumer)   <br>(x) -&gt; x++; (Function)   <br></code></pre></td></tr></table></figure><p>原理其实是： JVM帮我们动态生成了一个内部类，然后这个内部类实现了 Predicate/Consumer/Function 函数式接口。 重写了里面的test/accept/apply方法。</p><hr><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>Stream 和Collection结构化的数据不一样，Stream是一系列的元素，管道指的是一系列的聚合操作。每个stream只能使用一次</p><p>管道又分3个部分</p><ul><li>管道源： 可以是集合，数组，I/O channel， 产生器generator 等</li><li>中间操作： 每个中间操作，又会返回一个Stream，比如filter, map, reduce, find, match, sorted, 中间操作是“懒”操作，并不会真正进行遍历。</li><li>结束操作：必定是流的最后一个操作。 结束操作不会返回Stream，结束操作才进行真正的遍历行为，才会去进行中间操作的相关判断。</li></ul><p>中间操作可以有很多个，filter操作的参数就是Predicate函数，map操作的参数则是Function函数，forEach操作的参数可以是Consumer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">List&lt;String&gt; hotest &#x3D; Hot.entrySet().stream().sorted(new MapValueComparator()).map(Map.Entry::getKey).limit(topNum).collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h2 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h2><p>sorted/sort方法可以接受一个类，需实现Comparator接口 ，可以自定义排序的规则<br>无参数则有默认排序规则，例如对于Integer类型会比较其包装的值类型大小，对于String类型会以长度最小字符串为基准，逐一比较相同位置字符的ASCII码大小，如果都相同则比较字符串的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">.sorted(new MapValueComparator());<br><br>&#x2F;&#x2F; 比较器<br>static class MapValueComparator implements Comparator&lt;Map.Entry&lt;String, Double&gt;&gt; &#123;<br><br>    @Override<br>    public int compare(Map.Entry&lt;String, Double&gt; m1, Map.Entry&lt;String, Double&gt; m2) &#123;<br><br>        return m1.getValue().compareTo(m2.getValue());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://samsara98.gitee.io/samsara/&quot;&gt;SamsarA’s Blog&lt;/a&gt;! If you get any problems when reading my blog, you can&lt;br&gt;ask</summary>
      
    
    
    
    <category term="Study" scheme="https://wk1044481101.github.io/categories/Study/"/>
    
    
    <category term="-Java" scheme="https://wk1044481101.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>序列化_IO</title>
    <link href="https://wk1044481101.github.io/2021/01/29/%E5%BA%8F%E5%88%97%E5%8C%96_IO/"/>
    <id>https://wk1044481101.github.io/2021/01/29/%E5%BA%8F%E5%88%97%E5%8C%96_IO/</id>
    <published>2021-01-29T07:24:52.000Z</published>
    <updated>2021-07-01T09:51:47.772Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://samsara98.gitee.io/samsara/">SamsarA’s Blog</a>! If you get any problems when reading my blog, you can<br>ask me on <a href="https://gitee.com/samsara98/samsara">Gitee</a>.</p><h1 id="SamsarA’s-ZORK"><a href="#SamsarA’s-ZORK" class="headerlink" title="SamsarA’s ZORK"></a>SamsarA’s ZORK</h1><pre><code>#序列化  #SQLite  #OOP  #IO  </code></pre><p>&nbsp; You can get source code on my <a href="https://gitee.com/samsara98/zork">Gitee</a>.</p><ul><li>游戏简化操作，用大写字母和数字1234操控，例如WSAD对应北南西东移动，其余操作见游戏内提示</li><li>游戏有一个存档位,下次进入游戏时选继续游戏即可</li><li>游戏保存了通关玩家的数据，可通过封神榜查看</li><li>在地图探索时可以走动、查看状态、查看地图、存档</li><li>在探索是搜索可以获取该地区的道具或者进行交互，时常探索一下吧</li><li>人物属性：等级，攻击力，生命值，经验值, 感染程度</li></ul><hr><h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><p><em>Composition Over Inheritance，组合高于对象</em>   </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">组合：has-a的关系<br>需要某个功能，引用一个接口，实现该接口来实现功能，耦合度较低。通过实现不同的接口可组合出多种类，需要更换功能时无需改动主程序，<br>修改或更换接口的实现类即可。但是容易产生过多的类。如果类之间没有“is-a”的关系，可以通过实现接口与组合的方式来达到相同的目的。<br>设计模式中的策略模式可以很好的说明这一点，采用接口与组合的方式比采用继承的方式具有更好的可扩展性。  <br></code></pre></td></tr></table></figure><p>组合与继承都是有效地利用已有类的资源的重要方式。<br>但是二者的概念和使用场景皆不同</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">继承：is-a的关系   <br>继承需要实现父类的全部方法，容易产生冗余，只有当需要继承关系时才采用继承，并且要围绕继承设计。例如只有当需要子类向上转型为父类<br>时采用继承。过多的使用继承会破坏代码的可维护性，当父类被修改时，会影响到所有继承自它的子类，从而增加程序的维护难度和成本。<br></code></pre></td></tr></table></figure><hr><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p><em>游戏需要存档，即为保存游戏的状态，主要为游戏地点的姿态和角色状态，分别为对象List和对象，采用序列化方式保存数据</em><br><em>父类实现Serializable接口则子类无需实现即可序列化，若只有子类实现则序列化时父类的属性会丢失，只保留子类的属性</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class Character implements Serializable &#123;<br>    ...<br>    //用于反序列化,当反序列化目标版本与当前类不同时,可以兼容,不存在的属性置默认值<br>    private static final long serialVersionUID = 368751884395357044L; <br>    //子类序列化需要父类实现无参构造函数<br>    public <span class="hljs-function"><span class="hljs-title">Character</span></span>() &#123;&#125;    <br>    <br>    ...<br></code></pre></td></tr></table></figure><p><em>序列化及反序列化需要对象流，对象流建立在字节流上</em><br><em>InputStream和OutputStream为抽象类，FileInputStream/FileOutputStream 是InputStream/OutputStream子类</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">private void <span class="hljs-function"><span class="hljs-title">archive</span></span>() &#123;    //序列化，将对象序列化为文件<br><br>    ...<br>    <br>    try (FileOutputStream fos = new FileOutputStream(playerArchive);<br>         ObjectOutputStream oos = new ObjectOutputStream(fos);<br>         FileOutputStream fos2 = new FileOutputStream(placesArchive);<br>         ObjectOutputStream oos2 = new ObjectOutputStream(fos2)) &#123;<br>        <br>        oos.writeObject(player);<br>        oos2.writeObject(places);<br><br>    &#125; catch (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">private boolean <span class="hljs-function"><span class="hljs-title">readArchive</span></span>() &#123;   //反序列化从，序列化文件读入到对象<br>    <br>    ...<br>    //需要判断文件是否存在<br>    <span class="hljs-keyword">if</span> (!playArchive.exists() || !placesArchive.exists()) &#123;<br>        println(<span class="hljs-string">&quot;!存档不存在或者不完整!请检测&quot;</span> + PLAYER_ARCHIVE_FILE + <span class="hljs-string">&quot;以及&quot;</span> + PLACES_ARCHIVE_FILE);  <br>        <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    try (FileInputStream fis = new FileInputStream(playArchive);<br>         FileInputStream fis2 = new FileInputStream(placesArchive);<br>         ObjectInputStream ois = new ObjectInputStream(fis);<br>         ObjectInputStream ois2 = new ObjectInputStream(fis2)) &#123;<br>        player = (Player) ois.readObject();<br>        places = (ArrayList&lt;Place&gt;) ois2.readObject();<br>    &#125; catch (IOException | ClassNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    ...<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h2><p><em>游戏数据需要存取和读取可以通过数据库</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs bash">public void connectSqlite(String <span class="hljs-built_in">command</span>) &#123;     //连接SQLite 读取/更新<br><br>    try &#123;<br>        //加载驱动（反射）<br>        Class.forName(<span class="hljs-string">&quot;org.sqlite.JDBC&quot;</span>);   <br><br>&#125;    &#125; catch (ClassNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    try (Connection connection = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:sqlite:rank.db&quot;</span>)) &#123;  //数据库文件名称<br>        //如果rank表不存在则创建<br>        PreparedStatement preparedStatement = connection.prepareStatement(<span class="hljs-string">&quot;create table if not exists rank(name varchar(10), level int, kill int, exp int, creatTime varchar(20))&quot;</span>);<br>        preparedStatement.execute();<br>        switch (<span class="hljs-built_in">command</span>) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;save&quot;</span>:<br>                //预编译Statement<br>                String sql = <span class="hljs-string">&quot;insert into rank values(?, ?, ?, ?, ?)&quot;</span>;<br>                preparedStatement = connection.prepareStatement(sql);<br>                preparedStatement.setString(1, player.getName());<br>                preparedStatement.setInt(2, player.getLevel());<br>                preparedStatement.setInt(3, player.getKill());<br>                preparedStatement.setInt(4, player.getExp());<br>                preparedStatement.setString(5, player.getDATE());<br>                preparedStatement.execute();<br>                <span class="hljs-built_in">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;load&quot;</span>:<br>                //查询语句，按level排序，desc：降序，asc：升序<br>                sql = <span class="hljs-string">&quot;select * from rank order by level desc&quot;</span>;<br>                preparedStatement = connection.prepareStatement(sql);<br>                ResultSet resultSet = preparedStatement.executeQuery();<br>                println(<span class="hljs-string">&quot;姓名       等级    杀敌     经验        创建时间&quot;</span>);<br>                <span class="hljs-keyword">while</span> (resultSet.next()) &#123;<br>                    println(String.format(<span class="hljs-string">&quot;%s    %d     %d      %d       %s&quot;</span>,<br>                            resultSet.getString(1), resultSet.getInt(2), resultSet.getInt(3),<br>                            resultSet.getInt(4), resultSet.getString(5)));<br>                &#125;<br>                <span class="hljs-built_in">break</span>;<br>        &#125;<br>    &#125; catch (SQLException throwables) &#123;<br>        throwables.printStackTrace();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h2 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h2><p><em>用字符流加缓存流以字符形式读取文件</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash">private void printImage(File file) &#123;<br>    //创建文件字符流,在此基础上创建缓存流，一次性将一部分字符读取到内存中，速度较快<br>    try (FileReader fileReader = new FileReader(file);<br>         BufferedReader bufferedReader = new BufferedReader(fileReader)) &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            //用缓存流按行读取<br>            String line = bufferedReader.readLine();  <br>            //读到null即读完<br>            <span class="hljs-keyword">if</span> (null == line) &#123;<br>                <span class="hljs-built_in">break</span>;<br>            &#125;<br>            println(line);<br>        &#125;<br>    &#125; catch (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br>```   <br><br>*用Scanner读取txt文件*<br><br>```bash<br>private boolean <span class="hljs-function"><span class="hljs-title">loadGame</span></span>() &#123;<br>    <br>    ...<br>    <br>    Scanner scanner = new Scanner(new File(GAME_FILE));   //根据文件路径创建Scanner对象<br>    loadPlaces(scanner);    //同一个Scanner对象会按顺序读取文件，光标依次向下移动<br>    loadRoutes(scanner);<br>    loadTreasure(scanner);<br>    <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">    private void loadPlaces(Scanner scanner) &#123;<br>    // 读取地点<br>    int nPlaces = scanner.nextInt();            // 读取下一个int，空格为界限，无法读取有空格的内容<br>    scanner.next();                            //Scanner光标后移一位<br>    <span class="hljs-keyword">for</span> (int i = 0; i &lt; nPlaces; i++) &#123;<br>        int placeIndex = scanner.nextInt();     <br>        int danger = scanner.nextInt();     <br>        int infected = scanner.nextInt();   ;<br>        String placeName = scanner.next();     //读取下一个对象<br>        String placeMessage = scanner.next();      <br>        Place place = new Place(placeName);    <br>        <br>        ...<br>        <br>    &#125;<br>    <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://samsara98.gitee.io/samsara/&quot;&gt;SamsarA’s Blog&lt;/a&gt;! If you get any problems when reading my blog, you can&lt;br&gt;ask</summary>
      
    
    
    
    <category term="Study" scheme="https://wk1044481101.github.io/categories/Study/"/>
    
    
    <category term="-Java" scheme="https://wk1044481101.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>图像算法</title>
    <link href="https://wk1044481101.github.io/2021/01/19/%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://wk1044481101.github.io/2021/01/19/%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/</id>
    <published>2021-01-19T09:52:27.000Z</published>
    <updated>2021-07-01T10:00:43.267Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://samsara98.gitee.io/samsara/">SamsarA’s Blog</a>! If you get any problems when reading my blog, you can<br>ask me on <a href="https://gitee.com/samsara98/samsara">Gitee</a>.</p><h1 id="My-PS"><a href="#My-PS" class="headerlink" title="My PS"></a>My PS</h1><pre><code>#数组 #图像算法</code></pre><p>&nbsp; You can get source code on my <a href="https://gitee.com/samsara98/ps">Gitee</a>.</p><p><em>FEATHER</em></p><ul><li>马赛克滤镜</li><li>毛玻璃滤镜</li><li>增大图像饱和度</li><li>增大图像对比度</li><li>图像色调调整</li><li>生成灰度图</li><li>压缩图像</li><li>放大图像</li><li>橡皮擦</li><li>使用Face++的API，添加美颜以及滤镜功能。</li></ul><h2 id="图像处理算法"><a href="#图像处理算法" class="headerlink" title="图像处理算法"></a>图像处理算法</h2><p>本文需要配合源码<a href="https://gitee.com/samsara98/ps">Gitee</a></p><hr><h3 id="马赛克-毛玻璃"><a href="#马赛克-毛玻璃" class="headerlink" title="马赛克/毛玻璃"></a>马赛克/毛玻璃</h3><p><em>马赛克：选取半径内的像素点，随机选取一个来替换整个半径内的像素点</em><br><em>毛玻璃：选取半径内的像素点，随机选取一个来替换单个像素点</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">private int[][] mosaicPixel(int[][] pixelArrary, int x, int y, int RADIUS) &#123;  //xy为选取点，RADIUS为马赛克半径<br>    ...<br>    ...<br>&#125;<br><br>private int[][] groundGlassPixel(int[][] pixelArrary, int x, int y， int RADIUS) &#123;  //xy为选取点，RADIUS为毛玻璃半径<br>    ...<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="压缩-放大"><a href="#压缩-放大" class="headerlink" title="压缩/放大"></a>压缩/放大</h3><p><em>压缩算法：根据压缩倍数每隔若干像素点进行取点，复制到新图像中</em><br><em>放大算法：根据放大倍数对像素点进行取点后插空放置到新图像中，使用卷积算法补充像素点</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">public GImage zip(GImage <span class="hljs-built_in">source</span>) &#123;   // 压缩算法    <br>    ...<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">public GImage extend(GImage <span class="hljs-built_in">source</span>) &#123;   // 放大算法<br>    ...<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="灰度图"><a href="#灰度图" class="headerlink" title="灰度图"></a>灰度图</h3><p><em>灰度图算法：计算出像素点的亮度，调整rgb为亮度值，保留图像亮度，图像显示为不同程度的灰色</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">public GImage grey(GImage <span class="hljs-built_in">source</span>) &#123;   //灰度图算法<br>    ...<br>    pixelArrary[newy][newx] = GImage.createRGBPixel(luminosity, luminosity, luminosity);<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="饱和度增加"><a href="#饱和度增加" class="headerlink" title="饱和度增加"></a>饱和度增加</h3><p><em>饱和度算法：计算像素点的rgb平均值，增大rgb和平均值的偏移，使得图像饱和度增大</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">public GImage saturationEnhancement(GImage <span class="hljs-built_in">source</span>) &#123;   //饱和度增强算法<br>    ...<br>    rgb[i] += (rgb[i] - aver) * SATURATION;  //averrgb平均值，SATURATION偏移率<br>    rgb[i] = (rgb[i] &lt; 0) ? 0 : rgb[i];<br>    rgb[i] = (rgb[i] &gt; 255) ? 255 : rgb[i];<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="对比度增加"><a href="#对比度增加" class="headerlink" title="对比度增加"></a>对比度增加</h3><p><em>对比度算法：计算像素点的亮度平均值，增大每个点rgb和亮度平均值的偏移，使得图像对比度增大</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">public GImage contrastEnhancement(GImage <span class="hljs-built_in">source</span>) &#123;   //对比度增强算法<br>...<br>...<br><span class="hljs-keyword">for</span> (int y_ = 0; y_ &lt; Height; y_++) &#123;  //根据每个像素亮度在pixelLuminosity的位置，计算均衡化的亮度<br>    <span class="hljs-keyword">for</span> (int x_ = 0; x_ &lt; Width; x_++) &#123;<br>        int Luminosity = getLuminosity(pixelArray[y_][x_]);<br>        int r = GImage.getRed(pixelArray[y_][x_]);<br>        int g = GImage.getGreen(pixelArray[y_][x_]);<br>        int b = GImage.getBlue(pixelArray[y_][x_]);<br>        r += (Luminosity - averLu) * 0.6; //averLU亮度平均值<br>        g += (Luminosity - averLu) * 0.6;<br>        b += (Luminosity - averLu) * 0.6;<br>...<br>...<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="边界描绘"><a href="#边界描绘" class="headerlink" title="边界描绘"></a>边界描绘</h3><p><em>算法：计算半径内较该点明亮和暗黑的像素点的比例，在范围内判定为边界</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash">public GImage layOut(GImage <span class="hljs-built_in">source</span>) &#123;  //描绘边界<br>    ...<br>    ...<br>    int RADIUS = 3;  //检测半径<br>    <span class="hljs-keyword">for</span> (int y = 0; y &lt; Height; y +=  1) &#123;<br>        <span class="hljs-keyword">for</span> (int x = 0; x &lt; Width; x += 1) &#123;<br><br>            int MAX_x = Math.min(Width-1, x + RADIUS);  //选择检测的范围<br>            int MAX_y = Math.min(Height-1, y + RADIUS);<br>            int MIN_x = Math.max(0, x - RADIUS);<br>            int MIN_y = Math.max(0, y - RADIUS);<br><br>            int bigger = 0;<br>            int smaller = 0;<br>            int luminosity = getLuminosity(pixelArrary[y][x]);<br>            int r = GImage.getRed(pixelArrary[y][x]);<br>            int g = GImage.getGreen(pixelArrary[y][x]);<br>            int b = GImage.getBlue(pixelArrary[y][x]);<br><br>            <span class="hljs-keyword">for</span> (int y_ = MIN_y; y_ &lt;= MAX_y; y_++) &#123;  //计算半径内较暗较亮像素点个数<br>                <span class="hljs-keyword">for</span> (int x_ = MIN_x; x_ &lt;= MAX_x; x_++) &#123;<br>                    int luminosity_ = getLuminosity(pixelArrary[y_][x_]);<br>                    <span class="hljs-keyword">if</span> (luminosity &gt;= luminosity_) &#123;<br>                        smaller += 1;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        bigger += 1;  <br>                    &#125;<br>                &#125;<br>            &#125;<br>            double radio = (double) bigger / (smaller - 1);  //半径内明暗比例<br>            <span class="hljs-keyword">if</span> (radio &gt;= 0.7 &amp;&amp; radio &lt;= 1.3) &#123;<br>                newPixelArrary[y][x] = GImage.createRGBPixel(0,0,0);  //边界像素<br>            &#125;<br>        ...<br>        ...<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="FACE-beautify-API"><a href="#FACE-beautify-API" class="headerlink" title="FACE++ beautify API"></a>FACE++ beautify API</h2><p><em>通过POST方法调用webAPI，通过“multipart/form-data;”方法传入字段来调节美白、磨皮、瘦脸、大眼、去眉、滤镜功能。并以byte数组形式传入图片文件</em><br><em>返回bash64编码的二进制图像文件</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">public String beautify(File currentfile, int whitening,int smoothing,int thinface,<br>int shrink_face,int enlarge_eye, int remove_eyebrow,String filterType) throws Exception&#123;<br>        File file = currentfile;<br>        byte[] buff = getBytesFromFile(file);<br>        String url = <span class="hljs-string">&quot;https://api-cn.faceplusplus.com/facepp/v2/beautify&quot;</span>;<br>        HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();<br>        HashMap&lt;String, byte[]&gt; byteMap = new HashMap&lt;&gt;();<br>        ...<br>        ...<br>        map.put(<span class="hljs-string">&quot;whitening&quot;</span>, Integer.toString(whitening));<br>        map.put(<span class="hljs-string">&quot;smoothing&quot;</span>, Integer.toString(smoothing));<br>        map.put(<span class="hljs-string">&quot;thinface&quot;</span>, Integer.toString(thinface));<br>        map.put(<span class="hljs-string">&quot;shrink_face&quot;</span>, Integer.toString(shrink_face));<br>        map.put(<span class="hljs-string">&quot;enlarge_eye&quot;</span>, Integer.toString(enlarge_eye));<br>        map.put(<span class="hljs-string">&quot;remove_eyebrow&quot;</span>, Integer.toString(remove_eyebrow));<br>        map.put(<span class="hljs-string">&quot;filter_type&quot;</span>,filterType);<br>        ...<br>        ...<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">public GImage beautify(File currentfile, int whitening, int smoothing,int thinface, //文件，美颜参数：美白、磨皮、瘦脸（[0,100]）。<br>                        int shrink_face,int enlarge_eye, int remove_eyebrow, String filterType) &#123;    //缩脸、大眼、去眉（[0,100]）、滤镜（根据选择）<br>    FacePlus facePlus = new FacePlus();<br>    try &#123;<br>        String str = facePlus.beautify(currentfile, whitening, smoothing,thinface,shrink_face,enlarge_eye,remove_eyebrow, filterType);<br>        int index = str.indexOf(<span class="hljs-string">&quot;result\&quot;:\&quot;&quot;</span>);  //返回未String形式的字段map，截取其中result图像内容<br>        String str2 = str.substring(index + 9);<br>        str = str2.substring(0, str2.length() - 3);<br>        byte[] decoded = bash64.getDecoder().decode(str);  //解码bash64为二进制数组<br>        <span class="hljs-keyword">for</span> (int i = 0; i &lt; decoded.length; i++) &#123;  //转换为图像数组<br>            <span class="hljs-keyword">if</span> (decoded[i] &lt; 0) &#123;<br>                decoded[i] += 256;<br>            &#125;<br>        &#125;<br>        OutputStream out = new FileOutputStream(TMPFILE);   //TMPFILE：生成图像临时保存地址<br>        out.write(decoded);<br>        out.flush();<br>        out.close();<br>        <span class="hljs-built_in">return</span> new GImage(TMPFILE);<br>    &#125; catch (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-built_in">return</span> null;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://samsara98.gitee.io/samsara/&quot;&gt;SamsarA’s Blog&lt;/a&gt;! If you get any problems when reading my blog, you can&lt;br&gt;ask</summary>
      
    
    
    
    <category term="Study" scheme="https://wk1044481101.github.io/categories/Study/"/>
    
    
    <category term="-Java" scheme="https://wk1044481101.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Arkanoid-打砖块</title>
    <link href="https://wk1044481101.github.io/2021/01/13/Arkanoid-%E6%89%93%E7%A0%96%E5%9D%97/"/>
    <id>https://wk1044481101.github.io/2021/01/13/Arkanoid-%E6%89%93%E7%A0%96%E5%9D%97/</id>
    <published>2021-01-13T13:33:49.000Z</published>
    <updated>2021-07-01T09:58:36.671Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://samsara98.gitee.io/samsara/">SamsarA’s Blog</a>! If you get any problems when reading my blog, you can ask me on <a href="https://gitee.com/samsara98/samsara">Gitee</a>.</p><h1 id="Arkanoid"><a href="#Arkanoid" class="headerlink" title="Arkanoid"></a>Arkanoid</h1><pre><code>#GUI #动画 #回调  #事件监听</code></pre><p>&nbsp;  You can get source code on my <a href="https://gitee.com/samsara98/arkanoid">Gitee</a>.</p><p><em>超越Woz的打砖块</em></p><ul><li><p>小球碰到挡板反弹</p></li><li><p>玩家拥有3条命 </p></li><li><p>有积分系统，小球速度越快得分越高</p></li><li><p>打碎砖块有概率分裂出2个小球帮助打破砖块</p></li><li><p>砖块打破概率掉下来胶囊，拾取之后挡板变长 </p></li><li><p>砖块之后隐藏照片，不同关卡有不同图片，存在隐藏结局图片</p></li><li><p>理论上存在无限的关卡，速度随着关卡数提升</p></li></ul><h2 id="运行逻辑"><a href="#运行逻辑" class="headerlink" title="运行逻辑"></a>运行逻辑</h2><h3 id="Program程序先执行init（）初始化："><a href="#Program程序先执行init（）初始化：" class="headerlink" title="Program程序先执行init（）初始化："></a>Program程序先执行init（）初始化：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">public void <span class="hljs-function"><span class="hljs-title">init</span></span>()  &#123;<br>  addBgImge();  // 在屏幕上显示背景图片<br>  initGameData();  // 初始化游戏数据<br>  showGameInfo(); // 在屏幕上添加游戏信息<br>  makeBall();   // 往屏幕上添加小球<br>  makeBricks(); // 往屏幕上添加砖块<br>  makePaddle();  //往屏幕上添加挡板<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="然后执行run（）："><a href="#然后执行run（）：" class="headerlink" title="然后执行run（）："></a>然后执行run（）：</h3><p><em>每一个间隔内对小球状态进行监听，小球进行移动，若发送碰撞等事件执行相应命令；</em><br><em>对游戏状态进行监听：游戏结束/游戏胜利/进入下一关；</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash">public void <span class="hljs-function"><span class="hljs-title">run</span></span>() &#123;<br>    //启动鼠标<br>    addMouseListeners();<br>    // 初始化显示文字<br>    label.setLabel(<span class="hljs-string">&quot;&quot;</span>);<br>    //noinspection Infinite Loop Statement<br>    <span class="hljs-keyword">while</span> (Live &gt; 0) &#123;<br>        waitForClick();<br>        <span class="hljs-keyword">while</span> (label.getLabel().equals(<span class="hljs-string">&quot;&quot;</span>)) &#123; //label出现提示时停止循环，下一条命<br>            // 检查是否撞墙<br>            checkCollision();<br>            //检查是否撞到砖块<br>            checkBrickCollision();<br>            // 检测是否存在奖励方块，存在则要进行监听，检查是否碰到挡板<br>            checkRewardCollision();<br>            // 检测是否存在分裂球，存在则要进行监听，检查是否碰到墙壁和砖块<br>            checkRewardBallCollosion();<br>            // 移动小球的位置<br>            ball.move(vx, vy);<br>            // 延迟<br>            pause(DELAY);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;GG&quot;</span>.equals(label.getLabel() )) &#123;  //小球落地时触发<br>            lostHP();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;You Win The Game!&quot;</span>.equals(label.getLabel())) &#123;   //挡板长于游戏界面时触发<br>            WinTheGame();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;  NEXT STAGE~&quot;</span>.equals(label.getLabel()))&#123;   //清除所有砖块进入下一关时触发<br>            waitForClick();<br>            initAndRestart();   //初始化<br>        &#125;<br>    &#125;  //3命用尽时触发<br>    waitForClick();<br>    StageNum = 1;<br>    Score = 0;<br>    initAndRestart();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="监听方法"><a href="#监听方法" class="headerlink" title="监听方法"></a>监听方法</h3><p><em>对运动物体进行检测并对碰撞做出反应:</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>void checkCollision（）&#123;  //监听小球碰墙情况<br>  ...<br>&#125;<br><br><br>void checkBrickCollision（）&#123;  //监听小球碰砖块情况<br>  ...<br>&#125;<br><br>void checkReward（）&#123;  //监听奖励胶囊碰挡板情况<br>  ...<br>&#125;<br><br>void checkRewardBall（）&#123;     //监听分裂球碰砖块情况<br>  ...<br>&#125;<br><br>void checkRewardBall2（）&#123;    //监听分裂球碰墙情况<br>  ...<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>GObject <span class="hljs-function"><span class="hljs-title">getCollidingObject</span></span>() &#123; //判断小球四角，返回检测点碰撞的对象<br>...<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>/**<br>* Method: Hit Bottom Wall.<br>* -----------------------<br>* 判断小球是否击中了底部边界<br>  */<br>  boolean hitBottomWall(GObject g) &#123;<br>  <span class="hljs-built_in">return</span> g.getY() &gt;= getHeight() - g.getHeight() * 0.8;<br>  &#125;<br></code></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>/**<br>* Method: Hit Top Wall<br>* -----------------------<br>* 判断小球是否击中了顶部边界<br>  */<br>  boolean hitTopWall(GObject g) &#123;<br>  <span class="hljs-built_in">return</span> g.getY() &lt;= 0;<br>  &#125;<br><br></code></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>/**<br>* Method: Hit Right Wall<br>* -----------------------<br>* 判断小球是否击中了右侧边界<br>  */<br>  boolean hitRightWall(GObject g) &#123;<br>  <span class="hljs-built_in">return</span> g.getX() &gt;= getWidth() - g.getWidth();<br>  &#125;<br>  <br></code></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>/**<br>* Method: Hit Left Wall<br>* -----------------------<br>* 判断小球是否击中了左侧边界<br>  */<br>  boolean hitLeftWall(GObject g) &#123;<br>  <span class="hljs-built_in">return</span> g.getX() &lt;= 0;<br>  &#125;<br><br></code></pre></td></tr></table></figure><h3 id="对象生成"><a href="#对象生成" class="headerlink" title="对象生成"></a>对象生成</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><br>public void <span class="hljs-function"><span class="hljs-title">makeBall</span></span>() &#123;  //生成唯一小球<br>...<br>&#125;<br>  <br>  <br>public void <span class="hljs-function"><span class="hljs-title">makeRewardBall</span></span>() &#123;  //生成分裂球<br>...<br>&#125;<br><br>  <br>public void <span class="hljs-function"><span class="hljs-title">makeBricks</span></span>() &#123;      //生成砖块组<br>...<br>&#125;<br><br>  <br>public void <span class="hljs-function"><span class="hljs-title">makePaddle</span></span>() &#123;       //生成挡板<br>...<br>&#125;<br>  <br>public void <span class="hljs-function"><span class="hljs-title">makeReward</span></span>() &#123;      //生存奖励胶囊<br>...<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="对象跟踪"><a href="#对象跟踪" class="headerlink" title="对象跟踪"></a>对象跟踪</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>public void mouseMoved(MouseEvent e) &#123;  //挡板跟随鼠标移动<br>  paddle.setLocation(e.getX() - 0.5 * PADDLE_WIDTH, APPLICATION_HEIGHT - 50);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://samsara98.gitee.io/samsara/&quot;&gt;SamsarA’s Blog&lt;/a&gt;! If you get any problems when reading my blog, you can ask me</summary>
      
    
    
    
    <category term="Study" scheme="https://wk1044481101.github.io/categories/Study/"/>
    
    
    <category term="-Java" scheme="https://wk1044481101.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>C@sio_Calculator计算器</title>
    <link href="https://wk1044481101.github.io/2021/01/07/C@sio_Calculator%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>https://wk1044481101.github.io/2021/01/07/C@sio_Calculator%E8%AE%A1%E7%AE%97%E5%99%A8/</id>
    <published>2021-01-07T03:13:49.000Z</published>
    <updated>2021-07-01T10:00:43.279Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://samsara98.gitee.io/samsara/">SamsarA’s Blog</a>! If you get any problems when reading my blog, you can ask me on <a href="https://gitee.com/samsara98/samsara">Gitee</a>.</p><h1 id="C-SIO-Calculator"><a href="#C-SIO-Calculator" class="headerlink" title="C@SIO Calculator"></a>C@SIO Calculator</h1><pre><code>#IntelliJ IDEA #Swing #分支  #变量 #类型  #函数</code></pre><p>&nbsp;  You can get C@SIO_Calculator source code on my <a href="https://gitee.com/samsara98/calculator">Gitee</a>.</p><h1 id="自制计算器"><a href="#自制计算器" class="headerlink" title="自制计算器"></a>自制计算器</h1><h2 id="运行逻辑"><a href="#运行逻辑" class="headerlink" title="运行逻辑"></a>运行逻辑</h2><h3 id="程序从main启动："><a href="#程序从main启动：" class="headerlink" title="程序从main启动："></a>程序从main启动：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">public static void main(String[] args) &#123;<br>    Calculator calculator = new Calculator();<br>    JFrame frame = new JFrame();<br>    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br>    frame.add(calculator.panel);<br>    frame.setSize(250, 500);<br>    frame.setVisible(<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><em>Calculator类的无参构造函数：</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">Calculator</span></span>() &#123;<br>    panel = new JPanel();<br>    //修改计算机背景颜色<br>    panel.setBackground(Color.YELLOW);<br><br>    operator = null;<br>    //计算机初始显示<br>    displayText = <span class="hljs-string">&quot;C@SIO&quot;</span>;<br><br>    display = new JTextField(20);<br>    display.setEditable(<span class="hljs-literal">false</span>);<br>    display.setText(displayText);<br><br>    shouldAppendDigitToNumber = <span class="hljs-literal">false</span>;<br><br>    createButtons();<br>    attachListeners();<br>    addComponentsToPanel();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用Swing生成图像界面："><a href="#使用Swing生成图像界面：" class="headerlink" title="使用Swing生成图像界面："></a>使用Swing生成图像界面：</h3><p><em>添加按钮：</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">/**<br>  * 将屏幕和按键依次添加到计算器上<br>  */<br> void <span class="hljs-function"><span class="hljs-title">addComponentsToPanel</span></span>() &#123;<br>     ...<br>     ...<br> &#125;<br></code></pre></td></tr></table></figure><p><em>设置按钮监听：</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">/**<br> * 设置用户点击按键时计算器的反应<br> */<br>void <span class="hljs-function"><span class="hljs-title">attachListeners</span></span>()&#123;<br>    ...<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><em>创建按钮（赋值）：</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">/**<br>  * 创建好按键（但还没有<span class="hljs-string">&quot;贴&quot;</span>到屏幕上）<br>  */<br> void <span class="hljs-function"><span class="hljs-title">createButtons</span></span>() &#123;<br>     ...<br>     ...<br> &#125;<br></code></pre></td></tr></table></figure><p><em>计算器启动</em></p><p>按下按钮后执行actionPerformed:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">public void actionPerformed(ActionEvent e) &#123;<br>    //用户输入的按钮<br>    var <span class="hljs-built_in">command</span> = e.getActionCommand();<br>    char c = command.charAt(0);<br>    //创建一个运算符号的集合，用来判断输入的是否为运算符号<br>    List&lt;String&gt; strings = new ArrayList&lt;&gt;();<br>    Collections.addAll(strings, <span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;×&quot;</span>, <span class="hljs-string">&quot;÷&quot;</span>, <span class="hljs-string">&quot;Square&quot;</span>, <span class="hljs-string">&quot;Root&quot;</span>);<br>    ...<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="根据按下的按钮执行分支："><a href="#根据按下的按钮执行分支：" class="headerlink" title="根据按下的按钮执行分支："></a>根据按下的按钮执行分支：</h3><ul><li><p><em>如果输入数字：<br>shouldAppendDigitToNumber变量用来判断输入的数字应该作为开头还是接上之前输入的数字</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">//输入数字<br><span class="hljs-keyword">if</span> (isOperand(c)) &#123;<br>    <span class="hljs-keyword">if</span> (shouldAppendDigitToNumber) &#123;<br>        //将新输入的数字加在之前输入的数字后<br>        displayText += <span class="hljs-built_in">command</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        //输入的字符为数字开头<br>        displayText = <span class="hljs-built_in">command</span>;<br>        //可以继续输入数字<br>        shouldAppendDigitToNumber = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;...<br> ...<br></code></pre></td></tr></table></figure></li><li><p>*如果输入小数点：  </p></li></ul><p><em>strings.contains(last)用来判断上一次输入的字符是否为运算符，若出现输入“x”和”.“转换为&gt;&gt;”x0.”</em><br>  <em>displayText.contains(“.”)用来判断之前输入的数字是否已经包含“.”</em>   </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">//输入小数点，不允许出现多个“.”,若直接输入“.”自动补“0”<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>  <span class="hljs-keyword">if</span> (strings.contains(last)) &#123;<br>        displayText = <span class="hljs-string">&quot;0&quot;</span> + <span class="hljs-built_in">command</span>;<br>        shouldAppendDigitToNumber = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!displayText.contains(<span class="hljs-string">&quot;.&quot;</span>)) &#123;<br>        <span class="hljs-keyword">if</span> (shouldAppendDigitToNumber) &#123;<br>            displayText += <span class="hljs-built_in">command</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            displayText = <span class="hljs-string">&quot;0&quot;</span> + <span class="hljs-built_in">command</span>;<br>            shouldAppendDigitToNumber = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>  &#125;...<br>   ...<br></code></pre></td></tr></table></figure><ul><li><em>如果输入”=“:</em><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">//输入等号时运算，要求等号前不是运算符号<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;=&#x27;</span> &amp;&amp; !strings.contains(last)) &#123;<br>    double result = computeResult();<br>    //将计算结果写入展示文本<br>    <span class="hljs-keyword">if</span> (displayText.equals(<span class="hljs-string">&quot;Error&quot;</span>)) &#123;<br>        displayText = Double.toString(result);<br>    &#125;<br>    operator = null;<br>    operand1 = null;<br>    shouldAppendDigitToNumber = <span class="hljs-literal">false</span>;<br>&#125;...<br> ...<br></code></pre></td></tr></table></figure></li><li><em>如果输入AC(归零)：</em><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">//输入AC将显示“0”，清除之前记录的运算符和数字<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;A&#x27;</span>) &#123;<br>    displayText = <span class="hljs-string">&quot;0&quot;</span>;<br>    operator = null;<br>    operand1 = null;<br>    shouldAppendDigitToNumber = <span class="hljs-literal">false</span>;<br>    last = null;<br> &#125;...<br>  ...<br></code></pre></td></tr></table></figure></li><li><em>如果输入运算符：</em><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (null == last | !command.equals(last)) &#123;<br>        //输入了第一个数且上一个输入的指令不是运算符时连锁运算<br>        <span class="hljs-keyword">if</span> ((operand1 != null) &amp;&amp; !strings.contains(last)) &#123;<br>            double result = computeResult();<br>            <span class="hljs-keyword">if</span> (displayText.equals(<span class="hljs-string">&quot;Error&quot;</span>)) &#123;<br>                displayText = Double.toString(result);<br>            &#125;<br>        &#125;<br>        //开头输入减号可表示负数<br>        <span class="hljs-keyword">if</span> ((last == null) &amp; command.equals(<span class="hljs-string">&quot;-&quot;</span>)) &#123;<br>            displayText = <span class="hljs-string">&quot;-&quot;</span>;<br>            shouldAppendDigitToNumber = <span class="hljs-literal">true</span>;<br>            //数字后输入运算符将显示的字符提取为数字<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            operand1 = Double.parseDouble(displayText);<br>            shouldAppendDigitToNumber = <span class="hljs-literal">false</span>;<br>        &#125;<br>        operator = <span class="hljs-built_in">command</span>;<br>    &#125;<br>    ...<br>    ...<br></code></pre></td></tr></table></figure></li><li><em>完成输入判断和计算后：</em><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">//更新展示文本至计算器<br>display.setText(displayText);<br>//保存该次输入的指令至last变量<br>last = (c != <span class="hljs-string">&#x27;A&#x27;</span>) ? <span class="hljs-built_in">command</span> : null;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="特别功能"><a href="#特别功能" class="headerlink" title="特别功能"></a>特别功能</h2><p><em>除“0”时显示Error：</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">double divideNumbers(double a, double b) &#123;<br>    <span class="hljs-keyword">if</span> (b == 0) &#123;<br>        displayText = <span class="hljs-string">&quot;Error&quot;</span>;<br>        <span class="hljs-built_in">return</span> 0;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">return</span> a / b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>支持负数开多次方根：</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">double rootNumbers(double a, double b) &#123;<br>    <span class="hljs-keyword">if</span> (b % 2 != 0) &#123;<br>        <span class="hljs-built_in">return</span> Math.pow((a &lt; 0) ? -a : a, 1 / b) * ((a &lt; 0) ? -1 : 1);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">return</span> Math.pow(a, 1 / b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://samsara98.gitee.io/samsara/&quot;&gt;SamsarA’s Blog&lt;/a&gt;! If you get any problems when reading my blog, you can ask me</summary>
      
    
    
    
    <category term="Study" scheme="https://wk1044481101.github.io/categories/Study/"/>
    
    
    <category term="-Java" scheme="https://wk1044481101.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
