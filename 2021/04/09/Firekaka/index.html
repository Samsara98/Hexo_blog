<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Firekaka | SamsarA</title><script src="https://cdn.bootcss.com/valine/1.4.4/Valine.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/mermaid/8.8.2/mermaid.min.js"></script><script>mermaid.initialize({
  startOnLoad: true
  , theme: 'dark'
});</script><link rel="stylesheet" href="https://github.com/wk1044481101/wk1044481101.github.io/css/arknights.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("https://github.com/wk1044481101/wk1044481101.github.io/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('https://github.com/wk1044481101/wk1044481101.github.io/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="https://github.com/wk1044481101/wk1044481101.github.io/atom.xml" title="SamsarA" type="application/atom+xml">
</head><body><header><nav><a href="https://github.com/wk1044481101/wk1044481101.github.io/">Home</a><a href="https://github.com/wk1044481101/wk1044481101.github.io/archives/">Archives</a></nav></header><main><article><div id="post-bg"><div id="post-title"><h1>Firekaka</h1><hr></div><div id="post-content"><p>Welcome to <a target="_blank" rel="noopener" href="https://samsara98.gitee.io/samsara/">SamsarA’s Blog</a>! If you get any problems when reading my blog, you can<br>ask me on <a target="_blank" rel="noopener" href="https://gitee.com/samsara98/samsara">Gitee</a>.</p>
<h1 id="Firekaka"><a href="#Firekaka" class="headerlink" title="Firekaka"></a>Firekaka</h1><pre><code>#HTML #CSS #Parse #Dom #Enum</code></pre>
<ul>
<li>Let’s build a browser engine!</li>
</ul>
<p>&nbsp; You can get source code on my <a target="_blank" rel="noopener" href="https://gitee.com/samsara98/firekaka">Gitee</a>.</p>
<hr>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM 是Document Object Model( 文档对象模型 )的缩写，是把html里面 的各种数据当作对象进行操作的一种思路。当创建好一个页面并加载到浏览器时，<br>DOM就悄然而生，它会把网页文档转换为一个文档对象，主要功能是处理网页内容。 在这个文档对象里，所有的元素呈现出一种层次结构.</p>
<p>DOM把所有的html都转换为节点</p>
<ul>
<li>整个html是一个节点</li>
<li>元素(div,span)是节点</li>
<li>元素属性(class,id)是节点</li>
<li>元素内容是节点</li>
<li>注释也是节点<br><img src="dom.png"></li>
</ul>
<hr>
<h2 id="浏览器绘制html的过程"><a href="#浏览器绘制html的过程" class="headerlink" title="浏览器绘制html的过程"></a>浏览器绘制html的过程</h2><h3 id="解析HTML为DomNode"><a href="#解析HTML为DomNode" class="headerlink" title="解析HTML为DomNode"></a>解析HTML为DomNode</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">DomNode对象: 由html内容解析生成，分为两种ElementNode、TextNode<br>    <br>    ElementNode： 元素节点，包含标签名tagName，属性对attrs以及该节点的子节点列表children<br>    <br>    TextNode： 文本节点，无标签名，只包含文本内容。<br></code></pre></td></tr></table></figure>
<h3 id="解析CSS为Stylesheet"><a href="#解析CSS为Stylesheet" class="headerlink" title="解析CSS为Stylesheet"></a>解析CSS为Stylesheet</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">Stylesheet: 由CSS文件解析,包含多个Rule.   <br>    <br>    Rule: 包含选择器列表selectors以及CSS描述内容列表declarations.<br>        Selector: 选择器对象，可能包含下面三者中至少一个-&gt;选择标签：tagName，选择ID：id，选择类：className。<br>        Declaration: CSS描述对象，包含描述的key和value。<br></code></pre></td></tr></table></figure>
<h3 id="由DomNode和Stylesheet生成StyleNode"><a href="#由DomNode和Stylesheet生成StyleNode" class="headerlink" title="由DomNode和Stylesheet生成StyleNode"></a>由DomNode和Stylesheet生成StyleNode</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">StyledNode: DomNode和Stylesheet中的规则根据优先级进行匹配生成，包含其对应的DomNode节点、该节点对应的标签属性propertyMap以及子节点列表列表children。<br>   <br>MatchedRule： 包含一条规则Rule以及该规则选择器的优先级，用于匹配。<br></code></pre></td></tr></table></figure>
<h3 id="由StyleNode生成LayoutBox布局树"><a href="#由StyleNode生成LayoutBox布局树" class="headerlink" title="由StyleNode生成LayoutBox布局树"></a>由StyleNode生成LayoutBox布局树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">LayoutBox：由StyleNode的属性计算得到，包含盒子的位置、大小Dimensions、盒子的种类BoxType、盒子的子盒子children。<br> <br>    Dimensions：包含盒子的位置和内容大小content，盒子的边界情况padding、border、margin。<br>    <br>    Rect： 描述一个盒子，包含盒子的位置x、y，盒子的宽高：width、height。<br>    <br>    EdgeSize： 描述盒子的边界情况，包含左右上下距离left、right、top、bottom。<br>    <br>    Type： 枚举类型，盒子有四种类型BlockNode, InlineNode, AnonymousBlock,none。       <br>        BlockNode：块级元素，宽度取决于父类盒子宽度，高度取决于子盒子的总高度。<br>        InlineNod：内联元素，宽度取决于盒子宽度。<br>        AnonymousBlock： 匿名盒子，用于分隔block和inline<br>        none： 无样式。<br></code></pre></td></tr></table></figure>
<h3 id="根据布局树绘制html页面"><a href="#根据布局树绘制html页面" class="headerlink" title="根据布局树绘制html页面"></a>根据布局树绘制html页面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">Paint：根据布局树LayoutBox构建显示列表displayList，分别处理显示命令DispalyCommand，返回一个画布Canvas<br><br>DispalyCommand-&gt;SolidType： 一个布局显示命令，包含命令名：commandName，绘制范围rect，以及绘制颜色Type。<br><br>Canvas： 包含需要绘制的画布宽、高：width，height以及填充画布的像素列表pixels。<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h2><h3 id="枚举的定义"><a href="#枚举的定义" class="headerlink" title="枚举的定义"></a>枚举的定义</h3><ul>
<li>枚举类型一种特殊的数据类型，它既是一种类(class)类型却又比类类型多了些特殊的约束。</li>
</ul>
<p>在没有枚举类型时定义常量常见的方式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class DayDemo &#123;<br><br>    public static final int BlockNode =1;<br><br>    public static final int InlineNode=2;<br><br>    public static final int AnonymousBlock=3;<br><br>    public static final int None=4;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上述的常量定义常量的方式称为int枚举模式，这样的定义方式并没有什么错，<br>但它存在许多不足，如在类型安全和使用方便性上并没有多少好处，<br>如果存在定义int值相同的变量，混淆的几率还是很大的，<br>编译器也不会提出任何警告，因此这种方式在枚举出现后并不提倡，<br>现在我们利用枚举类型来重新定义上述的常量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">public enum Type &#123;<br>    BlockNode(<span class="hljs-string">&quot;block&quot;</span>,1), InlineNode(<span class="hljs-string">&quot;inline&quot;</span>,2), AnonymousBlock(<span class="hljs-string">&quot;anonymous&quot;</span>,3), None(<span class="hljs-string">&quot;none&quot;</span>,4);<br><br>    private final String <span class="hljs-built_in">type</span>;<br>    <br>    private final int i;<br><br>    private Type(String <span class="hljs-built_in">type</span>,int i) &#123;<br>        this.type = <span class="hljs-built_in">type</span>;<br>        this.i = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在定义枚举类型时我们使用的关键字是enum，与class关键字类似，<br>只不过前者是定义枚举类型，后者是定义类类型。值一般是大写的字母，多个值之间以逗号分隔。</p>
<p>同时我们应该知道的是枚举类型可以像类(class)类型一样，定义为一个单独的文件，当然也可以定义在其他类内部，<br>更重要的是枚举常量在类型安全性和便捷性都很有保证，如果出现类型问题编译器也会提示我们改进，<br>但务必记住枚举表示的类型其取值是必须有限的，也就是说每个值都是可以枚举出来的。</p>
<h3 id="枚举实现原理"><a href="#枚举实现原理" class="headerlink" title="枚举实现原理"></a>枚举实现原理</h3><p>Java Enum类型的语法结构尽管和java类的语法不一样，应该说差别比较大。 但是经过编译器编译之后产生的是一个class文件。 该class文件经过反编译可以看到实际上是生成了一个类， 该类继承了java.lang.Enum<E>。</p>
<p>而且枚举类是一个不可以被继承的final类。其枚举值(BlockNode,InlineNode…)都是Type类型的类静态常量，因此枚举类中的枚举值最好全部大写。</p>
<p>我们可以通过下面的方式来得到Type枚举类的一个实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">Type type&#x3D;Type.BlockNode;<br></code></pre></td></tr></table></figure>
<p>经过反编译(javap Type命令)之后得到的内容大致如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">//反编译Type.class<br>public final class Type extends java.lang.Enum&#123; <br>  //前面定义的枚举实例<br>    public static final WeekDay BlockNode; <br>    public static final WeekDay InlineNode; <br>    public static final WeekDay AnonymousBlock; <br>    public static final WeekDay None; <br>    static &#123;<br>      //实例化枚举实例<br>      BlockNode = new Type(<span class="hljs-string">&quot;block&quot;</span>,1);<br>      ...<br>      ...<br>    &#125;; <br>    <br>     //私有构造函数<br>    private Type(String <span class="hljs-built_in">type</span>) &#123;...&#125;<br>    <br>    //编译器为我们添加的静态的valueOf()方法，注意间接调用了Enum类的valueOf方法<br>    public static Type[] <span class="hljs-function"><span class="hljs-title">values</span></span>()&#123;...&#125;; <br>    <br>    //编译器为我们添加的静态的values()方法<br>    public static Type valueOf(java.lang.String)&#123;...&#125;; <br>&#125;<br></code></pre></td></tr></table></figure>
<p>即然枚举类是class，当然在枚举类型中有构造器，方法和数据域。但是，枚举类的构造器有很大的不同：</p>
<ul>
<li>(1) 构造器只是在构造枚举值的时候被调用。</li>
<li>(2) 构造器只能私有private，绝对不允许有public构造器。 这样可以保证外部代码无法新构造枚举类的实例。</li>
</ul>
<h3 id="Enum抽象类常见方法"><a href="#Enum抽象类常见方法" class="headerlink" title="Enum抽象类常见方法"></a>Enum抽象类常见方法</h3><p>Enum是所有 Java 语言枚举类型的公共基本类（注意Enum是抽象类），以下是它的常见方法：</p>
<ul>
<li>ordinal()方法: 返回枚举值在枚举类种的顺序。这个顺序根据枚举值声明的顺序而定。   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;返回类型：int<br>Type.BlockNode.ordinal();  &#x2F;&#x2F;返回结果：0<br>Type.InlineNode.ordinal();  &#x2F;&#x2F;返回结果：1<br></code></pre></td></tr></table></figure></li>
<li>compareTo()方法: Enum实现了java.lang.Comparable接口，因此可以比较象与指定对象的顺序。Enum中的compareTo返回的是两个枚举值的顺序之差。当然，前提是两个枚举值必须属于同一个枚举类，否则会抛出ClassCastException()异常。(具体可见源代码)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;返回类型：int<br>Type.BlockNode.compareTo(Type.InlineNode);  &#x2F;&#x2F;返回结果 -1<br></code></pre></td></tr></table></figure></li>
<li>values()方法： 静态方法，返回一个包含全部枚举值的数组。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">Type[] Types&#x3D;Type.values();<br>for(Type c:Types)&#123;<br>  System.out.print(c+&quot;,&quot;);<br>&#125;&#x2F;&#x2F;返回结果：BlockNode,InlineNode,AnonymousBlock,None<br></code></pre></td></tr></table></figure></li>
<li>toString()方法： 返回枚举常量的名称。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;返回类型：String<br>Type type&#x3D;Type.BlockNode;<br>System.out.println(type);&#x2F;&#x2F;返回结果: BlockNode<br></code></pre></td></tr></table></figure></li>
<li>valueOf()方法： 这个方法和toString方法是相对应的，返回带指定名称的指定枚举类型的枚举常量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;返回类型：static&lt;T extends Enum&lt;T&gt;&gt; T<br>Type.valueOf(&quot;block&quot;);   <br>&#x2F;&#x2F;返回结果: Type.BlockNode<br></code></pre></td></tr></table></figure></li>
<li>equals()方法： 比较两个枚举类对象的引用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;返回类型： boolean<br>Type.BlockNode.equals(Type.InlineNode) &#x2F;&#x2F;返回结果: false<br></code></pre></td></tr></table></figure></li>
<li>getDeclaringClass()方法： 返回与此枚举常量的枚举类型相对应的 Class 对象</li>
<li>name()方法： 返回此枚举常量的名称，在其枚举声明中对其进行声明</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>Enum类内部会有一个构造函数，该构造函数只能有编译器调用，我们是无法手动操作的，不妨看看Enum类的主要源码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs bash">//实现了Comparable<br>public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt;<br>        implements Comparable&lt;E&gt;, Serializable &#123;<br><br>    private final String name; //枚举字符串名称<br><br>    public final String <span class="hljs-function"><span class="hljs-title">name</span></span>() &#123;<br>        <span class="hljs-built_in">return</span> name;<br>    &#125;<br><br>    private final int ordinal;//枚举顺序值<br><br>    public final int <span class="hljs-function"><span class="hljs-title">ordinal</span></span>() &#123;<br>        <span class="hljs-built_in">return</span> ordinal;<br>    &#125;<br><br>    //枚举的构造方法，只能由编译器调用<br>    protected Enum(String name, int ordinal) &#123;<br>        this.name = name;<br>        this.ordinal = ordinal;<br>    &#125;<br><br>    public String <span class="hljs-function"><span class="hljs-title">toString</span></span>() &#123;<br>        <span class="hljs-built_in">return</span> name;<br>    &#125;<br><br>    public final boolean equals(Object other) &#123;<br>        <span class="hljs-built_in">return</span> this==other;<br>    &#125;<br><br>    //比较的是ordinal值<br>    public final int compareTo(E o) &#123;<br>        Enum&lt;?&gt; other = (Enum&lt;?&gt;)o;<br>        Enum&lt;E&gt; self = this;<br>        <span class="hljs-keyword">if</span> (self.getClass() != other.getClass() &amp;&amp; // optimization<br>            self.getDeclaringClass() != other.getDeclaringClass())<br>            throw new ClassCastException();<br>        <span class="hljs-built_in">return</span> self.ordinal - other.ordinal;//根据ordinal值比较大小<br>    &#125;<br><br>    @SuppressWarnings(<span class="hljs-string">&quot;unchecked&quot;</span>)<br>    public final Class&lt;E&gt; <span class="hljs-function"><span class="hljs-title">getDeclaringClass</span></span>() &#123;<br>        //获取class对象引用，getClass()是Object的方法<br>        Class&lt;?&gt; clazz = getClass();<br>        //获取父类Class对象引用<br>        Class&lt;?&gt; zuper = clazz.getSuperclass();<br>        <span class="hljs-built_in">return</span> (zuper == Enum.class) ? (Class&lt;E&gt;)clazz : (Class&lt;E&gt;)zuper;<br>    &#125;<br><br><br>    public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType,<br>                                                String name) &#123;<br>        //enumType.enumConstantDirectory()获取到的是一个map集合，key值就是name值，value则是枚举变量值   <br>        //enumConstantDirectory是class对象内部的方法，根据class对象获取一个map集合的值       <br>        T result = enumType.enumConstantDirectory().get(name);<br>        <span class="hljs-keyword">if</span> (result != null)<br>            <span class="hljs-built_in">return</span> result;<br>        <span class="hljs-keyword">if</span> (name == null)<br>            throw new NullPointerException(<span class="hljs-string">&quot;Name is null&quot;</span>);<br>        throw new IllegalArgumentException(<br>            <span class="hljs-string">&quot;No enum constant &quot;</span> + enumType.getCanonicalName() + <span class="hljs-string">&quot;.&quot;</span> + name);<br>    &#125;<br><br>    //.....省略其他没用的方法<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过Enum源码，可以知道，Enum实现了Comparable接口，这也是可以使用compareTo比较的原因，当然Enum构造函数也是存在的，该函数只能由编译器调用，我们只能使用enum关键字定义枚举.</p>
<h3 id="主要用法"><a href="#主要用法" class="headerlink" title="主要用法"></a>主要用法</h3><ul>
<li>1.常量</li>
<li>2.switch<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">switch (boxType.type) &#123;<br>            <span class="hljs-keyword">case</span> InlineNode:<br>                ...<br>                <span class="hljs-built_in">break</span>;<br>            <span class="hljs-keyword">case</span> AnonymousBlock:<br>                ...<br>                <span class="hljs-built_in">break</span>;<br>            <span class="hljs-keyword">case</span> BlockNode:<br>                ...<br>                <span class="hljs-built_in">break</span>;<br>            <span class="hljs-keyword">case</span> None:<br>                ...<br>                <span class="hljs-built_in">break</span>;<br>        &#125;<br></code></pre></td></tr></table></figure></li>
<li>3.向枚举中添加新方法<br>如果打算在enum类中定义方法，务必在声明完枚举实例后使用分号分开，倘若在枚举实例前定义任何方法，编译器都将会报错，无法编译通过，同时即使自定义了构造函数且enum的定义结束，<br>我们也永远无法手动调用构造函数创建枚举实例，毕竟这事只能由编译器执行。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">public enum Type &#123;<br>    //添加方法枚举时要用分号结束<br>    BlockNode(<span class="hljs-string">&quot;block&quot;</span>,1), InlineNode(<span class="hljs-string">&quot;inline&quot;</span>,2), AnonymousBlock(<span class="hljs-string">&quot;anonymous&quot;</span>,3), None(<span class="hljs-string">&quot;none&quot;</span>,4);<br>    <br>    //成员变量<br>    private final String <span class="hljs-built_in">type</span>;<br>    private final int i;<br>    <br>    //构造方法<br>    private Type(String <span class="hljs-built_in">type</span>,int i) &#123;<br>        this.type = <span class="hljs-built_in">type</span>;<br>        this.i = i;<br>    &#125;<br>    //定义方法<br>    public String <span class="hljs-function"><span class="hljs-title">getType</span></span>() &#123;<br>        <span class="hljs-built_in">return</span> <span class="hljs-built_in">type</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>4.覆盖枚举方法<br>父类Enum中的定义的方法只有toString方法没有使用final修饰，因此只能覆盖toString方法<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">public enum Type &#123;<br>    ...<br>    ...<br>    // 覆盖方法<br>    @Override<br>    public String <span class="hljs-function"><span class="hljs-title">toString</span></span>() &#123;<br>        <span class="hljs-built_in">return</span> this.index + <span class="hljs-string">&quot;_&quot;</span> + this.name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>5.实现接口<br>所有的枚举都继承自java.lang.Enum类。由于Java 不支持多继承，所以枚举对象不能再继承其他类。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">public interface interface_ &#123;<br>    void <span class="hljs-built_in">print</span>();<br><br>    String getInfo();<br>    &#125;<br><br>public enum Type implements interface_&#123;<br>    ...<br>    ...<br>    // 接口方法<br>    @Override<br>    public String <span class="hljs-function"><span class="hljs-title">getInfo</span></span>() &#123;<br>        <span class="hljs-built_in">return</span> this.name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>6.使用接口组织枚举 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">public interface Food &#123;<br>        enum Coffee implements Food &#123;<br>            BLACK_COFFEE, DECAF_COFFEE, LATTE, CAPPUCCINO<br>        &#125;<br><br>        enum Dessert implements Food &#123;<br>            FRUIT, CAKE, GELATO<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li>
<li>7.关于枚举集合的使用<br>java.util.EnumSet和java.util.EnumMap是两个枚举集合。EnumSet保证集合中的元素不重复;EnumMap中的 key是enum类型，而value则可以是任意类型。</li>
</ul>
<div id="paginator"></div></div><div id="post-footer"><hr><a href="https://github.com/wk1044481101/wk1044481101.github.io/2021/04/19/Html2/">← Prev Html2</a><span style="color: #fe2"> | </span><a href="https://github.com/wk1044481101/wk1044481101.github.io/2021/03/23/Html1/">Html1 Next →</a><hr></div><div id="bottom-btn"><a id="to-index" href="#post-index" title="index">≡</a><a id="to-top" href="#post-title" title="to top">∧</a></div><div id="Valine"></div><script>new Valine({
 el: '#Valine'
 , appId: ''
 , appKey: ''
 , placeholder: '此条评论委托企鹅物流发送'
})</script></div></article><aside><div id="about"><a href="https://github.com/wk1044481101/wk1044481101.github.io/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/"> Dr.SamsarA</a></h1><section id="total"><a id="total-archives" href="https://github.com/wk1044481101/wk1044481101.github.io/archives"><span class="total-title">Archives Total:</span><span class="total-number">15</span></a><div id="total-tags"><span class="total-title">Tags:</span><span class="total-number">5</span></div><div id="total-categories"><span class="total-title">Categories:</span><span class="total-number">1</span></div></section></div><div id="aside-block" style="order: 0"><h1>INDEX</h1><div id="post-index"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Firekaka"><span class="toc-number">1.</span> <span class="toc-text">Firekaka</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM"><span class="toc-number">1.1.</span> <span class="toc-text">DOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%98%E5%88%B6html%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">浏览器绘制html的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90HTML%E4%B8%BADomNode"><span class="toc-number">1.2.1.</span> <span class="toc-text">解析HTML为DomNode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90CSS%E4%B8%BAStylesheet"><span class="toc-number">1.2.2.</span> <span class="toc-text">解析CSS为Stylesheet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B1DomNode%E5%92%8CStylesheet%E7%94%9F%E6%88%90StyleNode"><span class="toc-number">1.2.3.</span> <span class="toc-text">由DomNode和Stylesheet生成StyleNode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B1StyleNode%E7%94%9F%E6%88%90LayoutBox%E5%B8%83%E5%B1%80%E6%A0%91"><span class="toc-number">1.2.4.</span> <span class="toc-text">由StyleNode生成LayoutBox布局树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E5%B8%83%E5%B1%80%E6%A0%91%E7%BB%98%E5%88%B6html%E9%A1%B5%E9%9D%A2"><span class="toc-number">1.2.5.</span> <span class="toc-text">根据布局树绘制html页面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Enum"><span class="toc-number">1.3.</span> <span class="toc-text">Enum</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">枚举的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.2.</span> <span class="toc-text">枚举实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Enum%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">Enum抽象类常见方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.3.4.</span> <span class="toc-text">源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%94%A8%E6%B3%95"><span class="toc-number">1.3.5.</span> <span class="toc-text">主要用法</span></a></li></ol></li></ol></li></ol></div></div><footer><nobr><span class="text-title">©</span><span class="text-content">1998 to 2021</span></nobr><wbr><nobr><span class="text-title">ICP</span><span class="text-content">——SAS——</span></nobr><wbr><wbr><nobr>published with&nbsp;<a target="_blank" rel="noopener" href="http://hexo.io">Hexo&nbsp;</a></nobr><wbr><nobr>Theme&nbsp;<a href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight&nbsp;</a></nobr><wbr><nobr>by&nbsp;<a href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="https://github.com/wk1044481101/wk1044481101.github.io/js/arknights.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script></body></html>