<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>YouNameIt | SamsarA</title><script src="https://cdn.bootcss.com/valine/1.4.4/Valine.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/mermaid/8.8.2/mermaid.min.js"></script><script>mermaid.initialize({
  startOnLoad: true
  , theme: 'dark'
});</script><link rel="stylesheet" href="/samsara/css/arknights.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/samsara/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/samsara/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/samsara/atom.xml" title="SamsarA" type="application/atom+xml">
</head><body><header><nav><a href="/samsara/">Home</a><a href="/samsara/archives/">Archives</a></nav></header><main><article><div id="post-bg"><div id="post-title"><h1>YouNameIt</h1><hr></div><div id="post-content"><p>Welcome to <a href="https://samsara98.gitee.io/samsara/">SamsarA’s Blog</a>! If you get any problems when reading my blog, you can<br>ask me on <a target="_blank" rel="noopener" href="https://gitee.com/samsara98/samsara">Gitee</a>.</p>
<h2 id="YouNameIt"><a href="#YouNameIt" class="headerlink" title="YouNameIt"></a>YouNameIt</h2><pre><code>#泛型  #函数式编程  #Stream  #Hash  </code></pre>
<p>&nbsp; You can get source code on my <a target="_blank" rel="noopener" href="https://gitee.com/samsara98/younameit">Gitee</a>.</p>
<hr>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。<br>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<p>泛型方法：</p>
<ul>
<li>所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的<E>）。</li>
<li>每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。</li>
<li>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。</li>
<li>泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等）。</li>
</ul>
<p>泛型类：</p>
<ul>
<li>和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。 和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。</li>
<li>一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。 因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。</li>
</ul>
<p>泛型集合：</p>
<ul>
<li>B extends A; 可放入A以及A的子类对象,例如B类的对象</li>
<li>基本对象放入必须是其包装类：Integer、Double…</li>
<li>A与B有继承关系，ArrayList<A/>和ArrayList<B>则没有继承</li>
</ul>
<h3 id="泛型集合-类-方法"><a href="#泛型集合-类-方法" class="headerlink" title="泛型集合/类/方法"></a>泛型集合/类/方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">ArrayList&lt;A&gt; heros = new ArrayList&lt;A&gt;();<br>// 后面的泛型类型可以省略<br>ArrayList&lt;A&gt; heros = new ArrayList&lt;&gt;();<br>// A与B有继承关系，ArrayList&lt;A&gt;和ArrayList&lt;B&gt;则没有继承关系<br>// 错误<br>ArrayList&lt;A&gt; lista = new ArrayList&lt;B&gt;;<br></code></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 设计这个类的时候，在类的声明上，加上一个&lt;T&gt;，表示该类支持泛型。<br>&#x2F;&#x2F; T是type的缩写，也可以使用任何其他的合法的变量，比如A,B,X都可以，但是一般约定成俗使用T，代表类型。<br>public class MyStack&lt;T&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。<br>&#x2F;&#x2F; 前面的&lt;T&gt;代表这是个泛型方法，返回的类型List&lt;T&gt;<br>public &lt;T&gt; List&lt;T&gt; foo(List&lt;T&gt; list)&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">？ extends泛型通配符：<br>ArrayList heroList&lt;? extends Hero&gt; 表示这是一个Hero泛型或者其子类泛型   <br>heroList 的泛型可能是Hero   <br>heroList 的泛型可能是APHero   <br>heroList 的泛型可能是ADHero  <br>所以 可以确凿的是，从heroList取出来的对象，一定是可以转型成Hero的，但是，不能往里面放东西<br></code></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">？ super泛型通配符：<br>ArrayList heroList&lt;? super Hero&gt; 表示这是一个Hero泛型或者其父类泛型<br>heroList的泛型可能是Hero<br>heroList的泛型可能是Object<br>可以往里面插入Hero以及Hero的子类<br>但是取出来有风险，因为不确定取出来是Hero还是Object <br></code></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">？泛型通配符：<br>表示任意泛型，所以只能以Object的形式取出来并且不能往里面放对象，因为不知道到底是一个什么泛型的容器 <br>ArrayList&lt;?&gt; generalList &#x3D; apHeroList;<br></code></pre></td></tr></table></figure>
<h3 id="类型擦拭"><a href="#类型擦拭" class="headerlink" title="类型擦拭"></a>类型擦拭</h3><p>Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉， 正确理解泛型概念的首要前提是理解类型擦除。Java的泛型基本上都是在编译器这个层次上实现的，<br>在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉， 这个过程成为类型擦除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 在JVM中<br>ArrayList&lt;String&gt; <br>相当于<br>ArrayList;<br>&#x2F;&#x2F; 编译器会限制我们只能向ArrayList&lt;String&gt;插入String对象，防止出错，但在JVM中是允许ArrayList&lt;String&gt;插入任意对象的。<br><br>public &lt;T&gt; void foo(&lt;T&gt; t)&#123;<br>&#125;<br>相当于<br>public void foo(Object t)&#123;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>注意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">public class MyStack&lt;T&gt; &#123;<br>    public MyStack(&lt;T&gt; t)&#123;<br>        &#x2F;&#x2F; 创建对象，可以通过编译<br>        T t &#x3D; t.getInstance();<br>        &#x2F;&#x2F;JVM中T无法得知，无法创建实例，无法编译<br>        Object object &#x3D; new T();<br>        &#x2F;&#x2F;可以通过编译<br>        Object object &#x3D; (T) new Object();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">public String foo(ArrayList&lt;String&gt; list)&#123;<br>&#125;<br>public String foo(ArrayList&lt;int&gt; list)&#123;<br>&#125;<br>&#x2F;&#x2F;这两个重载方法在JVM中是完全一样的，无法重载，方法名重复错误<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>实现Functional接口，主要有三种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">@Documented<br>@Retention(RetentionPolicy.RUNTIME)<br>@Target(ElementType.TYPE)<br>public @interface FunctionalInterface &#123;&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>有且仅有一个抽象方法</li>
<li>加上标注,则会触发JavaCompiler的检查。提供一层编译检查的保障。如果不符合，则会报错。</li>
<li>不能被覆盖之后，再声明为抽象方法，则不算抽象方法。例如接口实现了Object中的方法。</li>
<li>可用于lambda类型的使用方式</li>
</ul>
<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>Function是从T到R的一元映射函数。将参数T传递给一个函数，返回R。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs plain">@FunctionalInterface<br>public interface Function&lt;T, R&gt; &#123;<br>  &#x2F;**<br>  * Function&lt;Integer, Integer&gt; f &#x3D; s -&gt; s++; 有输入和输出<br>  * Function&lt;Integer, Integer&gt; g &#x3D; s -&gt; s*2;<br>  *&#x2F;<br>  R apply(T t);<br>  <br>  &#x2F;**<br>  * 表示在执行时，先执行before，然后使用before的输出当作当前函数输入。<br>  * f.compose(g).apply(1)<br>  *&#x2F;<br>  default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123;<br>         Objects.requireNonNull(before);<br>         return (V v) -&gt; apply(before.apply(v));<br>  &#125;<br>  <br>  &#x2F;**<br>  * 表示在执行时，先执行当前函数，并且执行after时使用当前函数的输出当作输入。<br>  * f.andThen(g).apply(1)<br>  *&#x2F;<br>  default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123;<br>        Objects.requireNonNull(after);<br>        return (T t) -&gt; after.apply(apply(t));<br>  &#125;<br>  <br>  &#x2F;**<br>  * identity方法会返回一个不进行任何处理的Function，即输出与输入值相等；<br>  * f.andThen(g).apply(1)<br>  * Function.identity().apply(&quot;a&quot;)<br>  *&#x2F; <br>  static &lt;T&gt; Function&lt;T, T&gt; identity() &#123;<br>         return t -&gt; t;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p>Predicate，判断的意思，判断某个东西是否满足某种条件； 因此它包含test方法，根据输入值来做逻辑判断，其结果为True或者False。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs plain">@FunctionalInterface<br>public interface Predicate&lt;T&gt; &#123;<br>    &#x2F;**<br>    * Predicate&lt;String&gt; p &#x3D; o -&gt; o.equals(&quot;test&quot;); 输出判断结果<br>    *&#x2F;<br>    boolean test(T t);<br>    <br>    &#x2F;**<br>    * and: 针对同一输入值，多个Predicate均返回True时返回True，否则返回False；<br>    * p.and(g).test(&quot;test&quot;)<br>    *&#x2F; <br>    default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123;<br>          Objects.requireNonNull(other);<br>          return (t) -&gt; test(t) &amp;&amp; other.test(t);<br>    &#125;<br>      <br>    &#x2F;**<br>    * 用于对原来的Predicate做取反处理；<br>    * 调用p.test(&quot;test&quot;)为True时，调用p.negate().test(&quot;test&quot;)就会是False；<br>    *&#x2F;       <br>     default Predicate&lt;T&gt; negate() &#123;<br>         return (t) -&gt; !test(t);<br>    &#125;<br>    <br>    &#x2F;**<br>    * or: 针对同一输入值，多个Predicate只要有一个返回True则返回True，否则返回False<br>    * p.or(g).test(&quot;test&quot;)；<br>    *&#x2F; <br>    default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) &#123;<br>         Objects.requireNonNull(other);<br>         return (t) -&gt; test(t) || other.test(t);<br>    &#125;<br>    <br>    &#x2F;**<br>    * isEqual方法接收一个Object对象,返回一个Predicate类型.此Predicate用于判断输入的对象是否与object对象相等(equals)<br>    * Predicate.isEqual(&quot;test&quot;).test(&quot;test&quot;);<br>    *&#x2F; <br>    static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) &#123;<br>         return (null &#x3D;&#x3D; targetRef)<br>                 ? Objects::isNull<br>                 : object -&gt; targetRef.equals(object);<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>Consumer是从T到void的函数，可以接受参数，但不返回任何结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plain">@FunctionalInterface<br>public interface Consumer&lt;T&gt; &#123;<br>    &#x2F;**<br>    * Consumer f &#x3D; System.out::println;  (类名&#x2F;对象名)::(静态方法&#x2F;方法)<br>    * Consumer f2 &#x3D; n -&gt; System.out.println(n + &quot;-F2&quot;);<br>    *&#x2F;<br>    void accept(T t);<br>    <br>    &#x2F;** <br>    * andThen指定在调用当前Consumer后是否还要调用其它的Consumer； <br>    * f.andThen(f).andThen(f).andThen(f).accept(&quot;test1&quot;);<br>    *&#x2F;<br>    default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123;<br>     Objects.requireNonNull(after);<br>     return (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p>Lambda 的基本结构为 (arguments) -&gt; body，有如下几种情况：</p>
<ul>
<li>参数类型可推导时，不需要指定类型，如 (a) -&gt; System.out.println(a)</li>
<li>当只有一个参数且类型可推导时，不强制写 (), 如 a -&gt; System.out.println(a)</li>
<li>参数指定类型时，必须有括号，如 (int a) -&gt; System.out.println(a)</li>
<li>参数可以为空，如 () -&gt; System.out.println(“hello”)</li>
<li>body 需要用 {} 包含语句，当只有一条语句时 {} 可省略<br>例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">(x) -&gt; x&gt;1; (Precidate)   <br>(x) -&gt; System.out::println; (Consumer)   <br>(x) -&gt; x++; (Function)   <br></code></pre></td></tr></table></figure>
<p>原理其实是： JVM帮我们动态生成了一个内部类，然后这个内部类实现了 Predicate/Consumer/Function 函数式接口。 重写了里面的test/accept/apply方法。</p>
<hr>
<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>Stream 和Collection结构化的数据不一样，Stream是一系列的元素，管道指的是一系列的聚合操作。每个stream只能使用一次</p>
<p>管道又分3个部分</p>
<ul>
<li>管道源： 可以是集合，数组，I/O channel， 产生器generator 等</li>
<li>中间操作： 每个中间操作，又会返回一个Stream，比如filter, map, reduce, find, match, sorted, 中间操作是“懒”操作，并不会真正进行遍历。</li>
<li>结束操作：必定是流的最后一个操作。 结束操作不会返回Stream，结束操作才进行真正的遍历行为，才会去进行中间操作的相关判断。</li>
</ul>
<p>中间操作可以有很多个，filter操作的参数就是Predicate函数，map操作的参数则是Function函数，forEach操作的参数可以是Consumer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">List&lt;String&gt; hotest &#x3D; Hot.entrySet().stream().sorted(new MapValueComparator()).map(Map.Entry::getKey).limit(topNum).collect(Collectors.toList());<br></code></pre></td></tr></table></figure>
<h2 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h2><p>sorted/sort方法可以接受一个类，需实现Comparator接口 ，可以自定义排序的规则<br>无参数则有默认排序规则，例如对于Integer类型会比较其包装的值类型大小，对于String类型会以长度最小字符串为基准，逐一比较相同位置字符的ASCII码大小，如果都相同则比较字符串的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">.sorted(new MapValueComparator());<br><br>&#x2F;&#x2F; 比较器<br>static class MapValueComparator implements Comparator&lt;Map.Entry&lt;String, Double&gt;&gt; &#123;<br><br>    @Override<br>    public int compare(Map.Entry&lt;String, Double&gt; m1, Map.Entry&lt;String, Double&gt; m2) &#123;<br><br>        return m1.getValue().compareTo(m2.getValue());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div id="paginator"></div></div><div id="post-footer"><hr><a href="/samsara/2021/03/02/Tetris/">← Prev Tetris</a><span style="color: #fe2"> | </span><a href="/samsara/2021/01/29/ZORK/">ZORK Next →</a><hr></div><div id="bottom-btn"><a id="to-index" href="#post-index" title="index">≡</a><a id="to-top" href="#post-title" title="to top">∧</a></div><div id="Valine"></div><script>new Valine({
 el: '#Valine'
 , appId: ''
 , appKey: ''
 , placeholder: '此条评论委托企鹅物流发送'
})</script></div></article><aside><div id="about"><a href="/samsara/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/"> Dr.SamsarA</a></h1><section id="total"><a id="total-archives" href="/samsara/archives"><span class="total-title">Archives Total:</span><span class="total-number">15</span></a><div id="total-tags"><span class="total-title">Tags:</span><span class="total-number">5</span></div><div id="total-categories"><span class="total-title">Categories:</span><span class="total-number">1</span></div></section></div><div id="aside-block" style="order: 0"><h1>INDEX</h1><div id="post-index"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#YouNameIt"><span class="toc-number">1.</span> <span class="toc-text">YouNameIt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E9%9B%86%E5%90%88-%E7%B1%BB-%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">泛型集合&#x2F;类&#x2F;方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%93%A6%E6%8B%AD"><span class="toc-number">2.3.</span> <span class="toc-text">类型擦拭</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Function"><span class="toc-number">3.1.</span> <span class="toc-text">Function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Predicate"><span class="toc-number">3.2.</span> <span class="toc-text">Predicate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Consumer"><span class="toc-number">3.3.</span> <span class="toc-text">Consumer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda"><span class="toc-number">3.4.</span> <span class="toc-text">Lambda</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream"><span class="toc-number">4.</span> <span class="toc-text">Stream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Comparator"><span class="toc-number">5.</span> <span class="toc-text">Comparator</span></a></li></ol></div></div><footer><nobr><span class="text-title">©</span><span class="text-content">1998 to 2021</span></nobr><wbr><nobr><span class="text-title">ICP</span><span class="text-content">——SAS——</span></nobr><wbr><wbr><nobr>published with&nbsp;<a target="_blank" rel="noopener" href="http://hexo.io">Hexo&nbsp;</a></nobr><wbr><nobr>Theme&nbsp;<a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight&nbsp;</a></nobr><wbr><nobr>by&nbsp;<a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/samsara/js/arknights.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script></body></html>